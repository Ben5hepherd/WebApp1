{"version":3,"sources":["durandal/plugins/history.js"],"names":["define","system","$","updateHash","location","fragment","replace","href","history","replaceState","document","title","hash","routeStripper","rootStripper","isExplorer","trailingSlash","interval","active","window","getHash","match","getFragment","forcePushState","_hasPushState","_wantsHashChange","pathname","search","root","indexOf","substr","length","activate","options","error","extend","hashChange","_wantsPushState","pushState","docMode","documentMode","oldIE","exec","navigator","userAgent","toLowerCase","iframe","hide","appendTo","contentWindow","navigate","on","checkUrl","_checkUrlInterval","setInterval","loc","atRoot","this","silent","loadUrl","startRoute","deactivate","off","clearInterval","current","fragmentOverride","routeHandler","undefined","trigger","isBoolean","url","slice","assign","open","close","navigateBack","back"],"mappings":"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","file":"../../../durandal/plugins/history.js","sourcesContent":["/**\r\n * Durandal 2.2.0 Copyright (c) 2010-2016 Blue Spire Consulting, Inc. All Rights Reserved.\r\n * Available via the MIT license.\r\n * see: http://durandaljs.com or https://github.com/BlueSpire/Durandal for details.\r\n */\r\n/**\r\n * This module is based on Backbone's core history support. It abstracts away the low level details of working with browser history and url changes in order to provide a solid foundation for a router.\r\n * @module history\r\n * @requires system\r\n * @requires jquery\r\n */\r\ndefine(['durandal/system', 'jquery'], function (system, $) {\r\n    // Cached regex for stripping a leading hash/slash and trailing space.\r\n    var routeStripper = /^[#\\/]|\\s+$/g;\r\n\r\n    // Cached regex for stripping leading and trailing slashes.\r\n    var rootStripper = /^\\/+|\\/+$/g;\r\n\r\n    // Cached regex for detecting MSIE.\r\n    var isExplorer = /msie [\\w.]+/;\r\n\r\n    // Cached regex for removing a trailing slash.\r\n    var trailingSlash = /\\/$/;\r\n\r\n    // Update the hash location, either replacing the current entry, or adding\r\n    // a new one to the browser history.\r\n    function updateHash(location, fragment, replace) {\r\n        if (replace) {\r\n            var href = location.href.replace(/(javascript:|#).*$/, '');\r\n\r\n            if (history.history.replaceState) {\r\n                history.history.replaceState({}, document.title, href + '#' + fragment); // using history.replaceState instead of location.replace to work around chrom bug\r\n            } else {\r\n                location.replace(href + '#' + fragment);\r\n            }\r\n        } else {\r\n            // Some browsers require that `hash` contains a leading #.\r\n            location.hash = '#' + fragment;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @class HistoryModule\r\n     * @static\r\n     */\r\n    var history = {\r\n        /**\r\n         * The setTimeout interval used when the browser does not support hash change events.\r\n         * @property {string} interval\r\n         * @default 50\r\n         */\r\n        interval: 50,\r\n        /**\r\n         * Indicates whether or not the history module is actively tracking history.\r\n         * @property {string} active\r\n         */\r\n        active: false\r\n    };\r\n    \r\n    // Ensure that `History` can be used outside of the browser.\r\n    if (typeof window !== 'undefined') {\r\n        history.location = window.location;\r\n        history.history = window.history;\r\n    }\r\n\r\n    /**\r\n     * Gets the true hash value. Cannot use location.hash directly due to a bug in Firefox where location.hash will always be decoded.\r\n     * @method getHash\r\n     * @param {string} [window] The optional window instance\r\n     * @return {string} The hash.\r\n     */\r\n    history.getHash = function(window) {\r\n        var match = (window || history).location.href.match(/#(.*)$/);\r\n        return match ? match[1] : '';\r\n    };\r\n    \r\n    /**\r\n     * Get the cross-browser normalized URL fragment, either from the URL, the hash, or the override.\r\n     * @method getFragment\r\n     * @param {string} fragment The fragment.\r\n     * @param {boolean} forcePushState Should we force push state?\r\n     * @return {string} he fragment.\r\n     */\r\n    history.getFragment = function(fragment, forcePushState) {\r\n        if (fragment == null) {\r\n            if (history._hasPushState || !history._wantsHashChange || forcePushState) {\r\n                fragment = history.location.pathname + history.location.search;\r\n                var root = history.root.replace(trailingSlash, '');\r\n                if (!fragment.indexOf(root)) {\r\n                    fragment = fragment.substr(root.length);\r\n                }\r\n            } else {\r\n                fragment = history.getHash();\r\n            }\r\n        }\r\n        \r\n        return fragment.replace(routeStripper, '');\r\n    };\r\n\r\n    /**\r\n     * Activate the hash change handling, returning `true` if the current URL matches an existing route, and `false` otherwise.\r\n     * @method activate\r\n     * @param {HistoryOptions} options.\r\n     * @return {boolean|undefined} Returns true/false from loading the url unless the silent option was selected.\r\n     */\r\n    history.activate = function(options) {\r\n        if (history.active) {\r\n            system.error(\"History has already been activated.\");\r\n        }\r\n\r\n        history.active = true;\r\n\r\n        // Figure out the initial configuration. Do we need an iframe?\r\n        // Is pushState desired ... is it available?\r\n        history.options = system.extend({}, { root: '/' }, history.options, options);\r\n        history.root = history.options.root;\r\n        history._wantsHashChange = history.options.hashChange !== false;\r\n        history._wantsPushState = !!history.options.pushState;\r\n        history._hasPushState = !!(history.options.pushState && history.history && history.history.pushState);\r\n\r\n        var fragment = history.getFragment();\r\n        var docMode = document.documentMode;\r\n        var oldIE = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));\r\n\r\n        // Normalize root to always include a leading and trailing slash.\r\n        history.root = ('/' + history.root + '/').replace(rootStripper, '/');\r\n\r\n        if (oldIE && history._wantsHashChange) {\r\n            history.iframe = $('<iframe src=\"javascript:0\" tabindex=\"-1\" />').hide().appendTo('body')[0].contentWindow;\r\n            history.navigate(fragment, false);\r\n        }\r\n\r\n        // Depending on whether we're using pushState or hashes, and whether\r\n        // 'onhashchange' is supported, determine how we check the URL state.\r\n        if (history._hasPushState) {\r\n            $(window).on('popstate', history.checkUrl);\r\n        } else if (history._wantsHashChange && ('onhashchange' in window) && !oldIE) {\r\n            $(window).on('hashchange', history.checkUrl);\r\n        } else if (history._wantsHashChange) {\r\n            history._checkUrlInterval = setInterval(history.checkUrl, history.interval);\r\n        }\r\n\r\n        // Determine if we need to change the base url, for a pushState link\r\n        // opened by a non-pushState browser.\r\n        history.fragment = fragment;\r\n        var loc = history.location;\r\n        var atRoot = loc.pathname.replace(/[^\\/]$/, '$&/') === history.root;\r\n\r\n        // Transition from hashChange to pushState or vice versa if both are requested.\r\n        if (history._wantsHashChange && history._wantsPushState) {\r\n            // If we've started off with a route from a `pushState`-enabled\r\n            // browser, but we're currently in a browser that doesn't support it...\r\n            if (!history._hasPushState && !atRoot) {\r\n                history.fragment = history.getFragment(null, true);\r\n                history.location.replace(history.root + history.location.search + '#' + history.fragment);\r\n                // Return immediately as browser will do redirect to new url\r\n                return true;\r\n\r\n            // Or if we've started out with a hash-based route, but we're currently\r\n            // in a browser where it could be `pushState`-based instead...\r\n            } else if (history._hasPushState && atRoot && loc.hash) {\r\n                this.fragment = history.getHash().replace(routeStripper, '');\r\n                this.history.replaceState({}, document.title, history.root + history.fragment + loc.search);\r\n            }\r\n        }\r\n\r\n        if (!history.options.silent) {\r\n            return history.loadUrl(options.startRoute);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Disable history, perhaps temporarily. Not useful in a real app, but possibly useful for unit testing Routers.\r\n     * @method deactivate\r\n     */\r\n    history.deactivate = function() {\r\n        $(window).off('popstate', history.checkUrl).off('hashchange', history.checkUrl);\r\n        clearInterval(history._checkUrlInterval);\r\n        history.active = false;\r\n    };\r\n\r\n    /**\r\n     * Checks the current URL to see if it has changed, and if it has, calls `loadUrl`, normalizing across the hidden iframe.\r\n     * @method checkUrl\r\n     * @return {boolean} Returns true/false from loading the url.\r\n     */\r\n    history.checkUrl = function() {\r\n        var current = history.getFragment();\r\n        if (current === history.fragment && history.iframe) {\r\n            current = history.getFragment(history.getHash(history.iframe));\r\n        }\r\n\r\n        if (current === history.fragment) {\r\n            return false;\r\n        }\r\n\r\n        if (history.iframe) {\r\n            history.navigate(current, false);\r\n        }\r\n        \r\n        history.loadUrl();\r\n    };\r\n    \r\n    /**\r\n     * Attempts to load the current URL fragment. A pass-through to options.routeHandler.\r\n     * @method loadUrl\r\n     * @return {boolean} Returns true/false from the route handler.\r\n     */\r\n    history.loadUrl = function(fragmentOverride) {\r\n        var fragment = history.fragment = history.getFragment(fragmentOverride);\r\n\r\n        return history.options.routeHandler ?\r\n            history.options.routeHandler(fragment) :\r\n            false;\r\n    };\r\n\r\n    /**\r\n     * Save a fragment into the hash history, or replace the URL state if the\r\n     * 'replace' option is passed. You are responsible for properly URL-encoding\r\n     * the fragment in advance.\r\n     * The options object can contain `trigger: false` if you wish to not have the\r\n     * route callback be fired, or `replace: true`, if\r\n     * you wish to modify the current URL without adding an entry to the history.\r\n     * @method navigate\r\n     * @param {string} fragment The url fragment to navigate to.\r\n     * @param {object|boolean} options An options object with optional trigger and replace flags. You can also pass a boolean directly to set the trigger option. Trigger is `true` by default.\r\n     * @return {boolean} Returns true/false from loading the url.\r\n     */\r\n    history.navigate = function(fragment, options) {\r\n        if (!history.active) {\r\n            return false;\r\n        }\r\n\r\n        if(options === undefined) {\r\n            options = {\r\n                trigger: true\r\n            };\r\n        }else if(system.isBoolean(options)) {\r\n            options = {\r\n                trigger: options\r\n            };\r\n        }\r\n\r\n        fragment = history.getFragment(fragment || '');\r\n\r\n        if (history.fragment === fragment) {\r\n            return;\r\n        }\r\n\r\n        history.fragment = fragment;\r\n\r\n        var url = history.root + fragment;\r\n\r\n        // Don't include a trailing slash on the root.\r\n        if(fragment === '' && url !== '/') {\r\n            url = url.slice(0, -1);\r\n        }\r\n\r\n        // If pushState is available, we use it to set the fragment as a real URL.\r\n        if (history._hasPushState) {\r\n            history.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\r\n\r\n            // If hash changes haven't been explicitly disabled, update the hash\r\n            // fragment to store history.\r\n        } else if (history._wantsHashChange) {\r\n            updateHash(history.location, fragment, options.replace);\r\n            \r\n            if (history.iframe && (fragment !== history.getFragment(history.getHash(history.iframe)))) {\r\n                // Opening and closing the iframe tricks IE7 and earlier to push a\r\n                // history entry on hash-tag change.  When replace is true, we don't\r\n                // want history.\r\n                if (!options.replace) {\r\n                    history.iframe.document.open().close();\r\n                }\r\n                \r\n                updateHash(history.iframe.location, fragment, options.replace);\r\n            }\r\n\r\n            // If you've told us that you explicitly don't want fallback hashchange-\r\n            // based history, then `navigate` becomes a page refresh.\r\n        } else {\r\n            return history.location.assign(url);\r\n        }\r\n\r\n        if (options.trigger) {\r\n            return history.loadUrl(fragment);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Navigates back in the browser history.\r\n     * @method navigateBack\r\n     */\r\n    history.navigateBack = function() {\r\n        history.history.back();\r\n    };\r\n\r\n    /**\r\n     * @class HistoryOptions\r\n     * @static\r\n     */\r\n\r\n    /**\r\n     * The function that will be called back when the fragment changes.\r\n     * @property {function} routeHandler\r\n     */\r\n\r\n    /**\r\n     * The url root used to extract the fragment when using push state.\r\n     * @property {string} root\r\n     */\r\n\r\n    /**\r\n     * Use hash change when present.\r\n     * @property {boolean} hashChange\r\n     * @default true\r\n     */\r\n\r\n    /**\r\n     * Use push state when present.\r\n     * @property {boolean} pushState\r\n     * @default false\r\n     */\r\n\r\n    /**\r\n     * Prevents loading of the current url when activating history.\r\n     * @property {boolean} silent\r\n     * @default false\r\n     */\r\n\r\n    return history;\r\n});\r\n"]}