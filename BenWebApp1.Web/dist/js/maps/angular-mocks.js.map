{"version":3,"sources":["angular-mocks.js"],"names":["window","angular","jsonStringToDate","string","match","R_ISO8061_STR","date","Date","tzHour","tzMin","toInt","setUTCFullYear","setUTCHours","str","parseInt","padNumberInMock","num","digits","trim","neg","length","substr","createHttpBackendMock","$rootScope","$timeout","$delegate","$browser","createResponse","status","data","headers","statusText","isFunction","isNumber","$httpBackend","method","url","callback","timeout","withCredentials","responseType","eventHandlers","uploadEventHandlers","prettyPrint","isString","RegExp","toJson","wrapResponse","wrapped","handleResponse","response","params","xhr","$$respHeaders","copy","getAllResponseHeaders","handleTimeout","i","ii","responses","splice","undefined","then","description","MockXhr","expectation","expectations","wasExpected","$$events","upload","matchData","Error","matchHeaders","shift","push","definition","definitions","defer","responsesPush","passThrough","originalHttpBackend","parseRoute","ret","regexp","keys","replace","_","slash","key","option","optional","star","name","createShortMethods","prefix","forEach","assertArgDefined","arguments","isUndefined","bind","$$originalHttpBackend","when","MockHttpExpectation","chain","respond","whenRoute","pathObj","expect","expectRoute","flush","count","skip","digest","$digest","isDefined","part","verifyNoOutstandingExpectation","join","verifyNoOutstandingRequest","unflushedDescriptions","map","res","resetExpectations","args","index","getUrlParams","u","slice","indexOf","split","sort","compareUrl","this","m","d","h","matchUrl","test","equals","fromJson","toString","pathParams","keyObj","exec","len","val","parseQuery","key_value","obj","queryStr","substring","keyValue","tryDecodeURIComponent","hasOwnProperty","call","isArray","value","decodeURIComponent","e","extend","$$lastInstance","open","async","$$method","$$url","$$async","$$reqHeaders","send","$$data","setRequestHeader","getResponseHeader","header","lowercase","headerVal","headerName","lines","abort","noop","addEventListener","listener","createControllerDecorator","compileProvider","mock","$ControllerDecorator","expression","locals","later","ident","preAssignBindingsEnabled","instantiate","instance","$BrowserProvider","$get","$Browser","self","isMock","$$lastUrl","pollFns","outstandingRequestCount","outstandingRequestCallbacks","$$incOutstandingRequestCount","$$completeOutstandingRequest","fn","pop","notifyWhenNoOutstandingRequests","onUrlChange","$$state","$$lastState","$$applicationDestroyed","$$checkUrlChange","deferredFns","deferredNextId","delay","time","now","id","a","b","cancel","deferId","fnIndex","nextTime","$$baseHref","baseHref","prototype","poll","pollFn","state","$ExceptionHandlerProvider","handler","mode","errors","$LogProvider","concat","array1","array2","Array","debug","debugEnabled","flag","$log","log","logs","warn","info","error","reset","assertEmpty","logLevel","logItem","String","stack","unshift","$IntervalProvider","$q","$$q","repeatFns","nextRepeatId","$interval","invokeApply","tick","deferred","notify","iteration","resolve","promise","$$intervalId","skipApply","$apply","hasParams","apply","reject","millis","before","task","TzDate","offset","timestamp","tsStr","origDate","getTime","isNaN","message","localOffset","getTimezoneOffset","offsetDiff","toLocaleDateString","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","getDay","toISOString","unimplementedMethods","methodName","animate","module","angularVersion","config","$provide","factory","reflowFn","totalReflows","queue","queueFn","decorator","runners","animateJsConstructor","animator","$closeAndFlush","runner","end","animateCssConstructor","element","options","$$rAF","$animateCss","$$animateJs","$$forceReflow","$$animateAsyncRun","on","off","pin","reflows","enabled","closeAndFlush","hideErrors","doNextRun","somethingFlushed","event","dump","object","serialize","out","isElement","append","clone","html","o","isObject","$eval","serializeScope","scope","$id","Object","child","$$childHead","$$nextSibling","$httpBackendDecorator","$TimeoutDecorator","formatPendingTasksAsString","tasks","result","verifyNoPendingTasks","$RAFDecorator","rafFn","supported","originalRootElement","$RootElementProvider","$injector","$ComponentControllerProvider","$compileProvider","$controller","componentName","bindings","directives","get","candidateDirectives","filter","directiveInfo","controller","controllerAs","restrict","$scope","$new","provider","$exceptionHandler","$rootElement","$componentController","$RootScopeDecorator","e2e","countChildScopes","currentScope","pendingChildHeads","countWatchers","$$watchers","$rootScopePrototype","getPrototypeOf","$countChildScopes","$countWatchers","jasmineOrMocha","InjectorState","shared","sharedError","cleanupAfterEach","currentSpec","injectorState","annotatedFunctions","wasInjectorCreated","$$annotate","injector","$inject","workFn","modules","$modules","moduleFns","$providerInjector","invoke","$$beforeAllHook","beforeAll","$$afterAllHook","after","afterAll","$$currentSpec","to","sharedInjector","initialized","$$cleanup","$$beforeEach","k","$$afterEach","rootNode","cleanUpNodes","cleanData","$destroy","fragments","callbacks","$$counter","beforeEach","setup","afterEach","teardown","ErrorAddingDeclarationLocationStack","errorForStack","line","sourceId","stackArray","inject","WorkFn","strictDi","$injectorStrict","moduleFn","blockFns","annotate","jasmine","mocha","supportsTouchEvents","_cached","document","createTouch","createTouchList","createEvent","createTouchEvent","eventType","x","y","evnt","Event","touch","touches","supportsEventBubblingInDetachedTree","doc","parent","createElement","cloneNode","appendChild","initEvent","dispatchEvent","triggerForPath","stop","_stopPropagation","stopPropagation","patchEventTargetForBubbling","parentNode","target","_target","defineProperty","isAttachedToDocument","browserTrigger","eventData","pressed","nodeName","relatedTarget","inputType","type","toLowerCase","text","textarea","hidden","password","button","submit","image","checkbox","radio","select-one","select-multiple","_default_","WebKitTransitionEvent","TransitionEvent","initTransitionEvent","elapsedTime","WebKitAnimationEvent","AnimationEvent","initAnimationEvent","bubbles","cancelable","view","ctrlKey","altKey","shiftKey","metaKey","keyCode","charCode","which","initMouseEvent","$manualTimeStamp","timeStamp","finalProcessDefault","originalPreventDefault","preventDefault","appWindow","ownerDocument","defaultView","fakeProcessDefault"],"mappings":"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","file":"../angular-mocks.js","sourcesContent":["/**\n * @license AngularJS v1.6.6\n * (c) 2010-2017 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {\n\n'use strict';\n\n/**\n * @ngdoc object\n * @name angular.mock\n * @description\n *\n * Namespace from 'angular-mocks.js' which contains testing related code.\n *\n */\nangular.mock = {};\n\n/**\n * ! This is a private undocumented service !\n *\n * @name $browser\n *\n * @description\n * This service is a mock implementation of {@link ng.$browser}. It provides fake\n * implementation for commonly used browser apis that are hard to test, e.g. setTimeout, xhr,\n * cookies, etc.\n *\n * The api of this service is the same as that of the real {@link ng.$browser $browser}, except\n * that there are several helper methods available which can be used in tests.\n */\nangular.mock.$BrowserProvider = function() {\n  this.$get = function() {\n    return new angular.mock.$Browser();\n  };\n};\n\nangular.mock.$Browser = function() {\n  var self = this;\n\n  this.isMock = true;\n  self.$$url = 'http://server/';\n  self.$$lastUrl = self.$$url; // used by url polling fn\n  self.pollFns = [];\n\n  // Testability API\n\n  var outstandingRequestCount = 0;\n  var outstandingRequestCallbacks = [];\n  self.$$incOutstandingRequestCount = function() { outstandingRequestCount++; };\n  self.$$completeOutstandingRequest = function(fn) {\n    try {\n      fn();\n    } finally {\n      outstandingRequestCount--;\n      if (!outstandingRequestCount) {\n        while (outstandingRequestCallbacks.length) {\n          outstandingRequestCallbacks.pop()();\n        }\n      }\n    }\n  };\n  self.notifyWhenNoOutstandingRequests = function(callback) {\n    if (outstandingRequestCount) {\n      outstandingRequestCallbacks.push(callback);\n    } else {\n      callback();\n    }\n  };\n\n  // register url polling fn\n\n  self.onUrlChange = function(listener) {\n    self.pollFns.push(\n      function() {\n        if (self.$$lastUrl !== self.$$url || self.$$state !== self.$$lastState) {\n          self.$$lastUrl = self.$$url;\n          self.$$lastState = self.$$state;\n          listener(self.$$url, self.$$state);\n        }\n      }\n    );\n\n    return listener;\n  };\n\n  self.$$applicationDestroyed = angular.noop;\n  self.$$checkUrlChange = angular.noop;\n\n  self.deferredFns = [];\n  self.deferredNextId = 0;\n\n  self.defer = function(fn, delay) {\n    // Note that we do not use `$$incOutstandingRequestCount` or `$$completeOutstandingRequest`\n    // in this mock implementation.\n    delay = delay || 0;\n    self.deferredFns.push({time:(self.defer.now + delay), fn:fn, id: self.deferredNextId});\n    self.deferredFns.sort(function(a, b) { return a.time - b.time;});\n    return self.deferredNextId++;\n  };\n\n\n  /**\n   * @name $browser#defer.now\n   *\n   * @description\n   * Current milliseconds mock time.\n   */\n  self.defer.now = 0;\n\n\n  self.defer.cancel = function(deferId) {\n    var fnIndex;\n\n    angular.forEach(self.deferredFns, function(fn, index) {\n      if (fn.id === deferId) fnIndex = index;\n    });\n\n    if (angular.isDefined(fnIndex)) {\n      self.deferredFns.splice(fnIndex, 1);\n      return true;\n    }\n\n    return false;\n  };\n\n\n  /**\n   * @name $browser#defer.flush\n   *\n   * @description\n   * Flushes all pending requests and executes the defer callbacks.\n   *\n   * @param {number=} number of milliseconds to flush. See {@link #defer.now}\n   */\n  self.defer.flush = function(delay) {\n    var nextTime;\n\n    if (angular.isDefined(delay)) {\n      // A delay was passed so compute the next time\n      nextTime = self.defer.now + delay;\n    } else {\n      if (self.deferredFns.length) {\n        // No delay was passed so set the next time so that it clears the deferred queue\n        nextTime = self.deferredFns[self.deferredFns.length - 1].time;\n      } else {\n        // No delay passed, but there are no deferred tasks so flush - indicates an error!\n        throw new Error('No deferred tasks to be flushed');\n      }\n    }\n\n    while (self.deferredFns.length && self.deferredFns[0].time <= nextTime) {\n      // Increment the time and call the next deferred function\n      self.defer.now = self.deferredFns[0].time;\n      self.deferredFns.shift().fn();\n    }\n\n    // Ensure that the current time is correct\n    self.defer.now = nextTime;\n  };\n\n  self.$$baseHref = '/';\n  self.baseHref = function() {\n    return this.$$baseHref;\n  };\n};\nangular.mock.$Browser.prototype = {\n\n  /**\n   * @name $browser#poll\n   *\n   * @description\n   * run all fns in pollFns\n   */\n  poll: function poll() {\n    angular.forEach(this.pollFns, function(pollFn) {\n      pollFn();\n    });\n  },\n\n  url: function(url, replace, state) {\n    if (angular.isUndefined(state)) {\n      state = null;\n    }\n    if (url) {\n      this.$$url = url;\n      // Native pushState serializes & copies the object; simulate it.\n      this.$$state = angular.copy(state);\n      return this;\n    }\n\n    return this.$$url;\n  },\n\n  state: function() {\n    return this.$$state;\n  }\n};\n\n\n/**\n * @ngdoc provider\n * @name $exceptionHandlerProvider\n *\n * @description\n * Configures the mock implementation of {@link ng.$exceptionHandler} to rethrow or to log errors\n * passed to the `$exceptionHandler`.\n */\n\n/**\n * @ngdoc service\n * @name $exceptionHandler\n *\n * @description\n * Mock implementation of {@link ng.$exceptionHandler} that rethrows or logs errors passed\n * to it. See {@link ngMock.$exceptionHandlerProvider $exceptionHandlerProvider} for configuration\n * information.\n *\n *\n * ```js\n *   describe('$exceptionHandlerProvider', function() {\n *\n *     it('should capture log messages and exceptions', function() {\n *\n *       module(function($exceptionHandlerProvider) {\n *         $exceptionHandlerProvider.mode('log');\n *       });\n *\n *       inject(function($log, $exceptionHandler, $timeout) {\n *         $timeout(function() { $log.log(1); });\n *         $timeout(function() { $log.log(2); throw 'banana peel'; });\n *         $timeout(function() { $log.log(3); });\n *         expect($exceptionHandler.errors).toEqual([]);\n *         expect($log.assertEmpty());\n *         $timeout.flush();\n *         expect($exceptionHandler.errors).toEqual(['banana peel']);\n *         expect($log.log.logs).toEqual([[1], [2], [3]]);\n *       });\n *     });\n *   });\n * ```\n */\n\nangular.mock.$ExceptionHandlerProvider = function() {\n  var handler;\n\n  /**\n   * @ngdoc method\n   * @name $exceptionHandlerProvider#mode\n   *\n   * @description\n   * Sets the logging mode.\n   *\n   * @param {string} mode Mode of operation, defaults to `rethrow`.\n   *\n   *   - `log`: Sometimes it is desirable to test that an error is thrown, for this case the `log`\n   *     mode stores an array of errors in `$exceptionHandler.errors`, to allow later assertion of\n   *     them. See {@link ngMock.$log#assertEmpty assertEmpty()} and\n   *     {@link ngMock.$log#reset reset()}.\n   *   - `rethrow`: If any errors are passed to the handler in tests, it typically means that there\n   *     is a bug in the application or test, so this mock will make these tests fail. For any\n   *     implementations that expect exceptions to be thrown, the `rethrow` mode will also maintain\n   *     a log of thrown errors in `$exceptionHandler.errors`.\n   */\n  this.mode = function(mode) {\n\n    switch (mode) {\n      case 'log':\n      case 'rethrow':\n        var errors = [];\n        handler = function(e) {\n          if (arguments.length === 1) {\n            errors.push(e);\n          } else {\n            errors.push([].slice.call(arguments, 0));\n          }\n          if (mode === 'rethrow') {\n            throw e;\n          }\n        };\n        handler.errors = errors;\n        break;\n      default:\n        throw new Error('Unknown mode \\'' + mode + '\\', only \\'log\\'/\\'rethrow\\' modes are allowed!');\n    }\n  };\n\n  this.$get = function() {\n    return handler;\n  };\n\n  this.mode('rethrow');\n};\n\n\n/**\n * @ngdoc service\n * @name $log\n *\n * @description\n * Mock implementation of {@link ng.$log} that gathers all logged messages in arrays\n * (one array per logging level). These arrays are exposed as `logs` property of each of the\n * level-specific log function, e.g. for level `error` the array is exposed as `$log.error.logs`.\n *\n */\nangular.mock.$LogProvider = function() {\n  var debug = true;\n\n  function concat(array1, array2, index) {\n    return array1.concat(Array.prototype.slice.call(array2, index));\n  }\n\n  this.debugEnabled = function(flag) {\n    if (angular.isDefined(flag)) {\n      debug = flag;\n      return this;\n    } else {\n      return debug;\n    }\n  };\n\n  this.$get = function() {\n    var $log = {\n      log: function() { $log.log.logs.push(concat([], arguments, 0)); },\n      warn: function() { $log.warn.logs.push(concat([], arguments, 0)); },\n      info: function() { $log.info.logs.push(concat([], arguments, 0)); },\n      error: function() { $log.error.logs.push(concat([], arguments, 0)); },\n      debug: function() {\n        if (debug) {\n          $log.debug.logs.push(concat([], arguments, 0));\n        }\n      }\n    };\n\n    /**\n     * @ngdoc method\n     * @name $log#reset\n     *\n     * @description\n     * Reset all of the logging arrays to empty.\n     */\n    $log.reset = function() {\n      /**\n       * @ngdoc property\n       * @name $log#log.logs\n       *\n       * @description\n       * Array of messages logged using {@link ng.$log#log `log()`}.\n       *\n       * @example\n       * ```js\n       * $log.log('Some Log');\n       * var first = $log.log.logs.unshift();\n       * ```\n       */\n      $log.log.logs = [];\n      /**\n       * @ngdoc property\n       * @name $log#info.logs\n       *\n       * @description\n       * Array of messages logged using {@link ng.$log#info `info()`}.\n       *\n       * @example\n       * ```js\n       * $log.info('Some Info');\n       * var first = $log.info.logs.unshift();\n       * ```\n       */\n      $log.info.logs = [];\n      /**\n       * @ngdoc property\n       * @name $log#warn.logs\n       *\n       * @description\n       * Array of messages logged using {@link ng.$log#warn `warn()`}.\n       *\n       * @example\n       * ```js\n       * $log.warn('Some Warning');\n       * var first = $log.warn.logs.unshift();\n       * ```\n       */\n      $log.warn.logs = [];\n      /**\n       * @ngdoc property\n       * @name $log#error.logs\n       *\n       * @description\n       * Array of messages logged using {@link ng.$log#error `error()`}.\n       *\n       * @example\n       * ```js\n       * $log.error('Some Error');\n       * var first = $log.error.logs.unshift();\n       * ```\n       */\n      $log.error.logs = [];\n        /**\n       * @ngdoc property\n       * @name $log#debug.logs\n       *\n       * @description\n       * Array of messages logged using {@link ng.$log#debug `debug()`}.\n       *\n       * @example\n       * ```js\n       * $log.debug('Some Error');\n       * var first = $log.debug.logs.unshift();\n       * ```\n       */\n      $log.debug.logs = [];\n    };\n\n    /**\n     * @ngdoc method\n     * @name $log#assertEmpty\n     *\n     * @description\n     * Assert that all of the logging methods have no logged messages. If any messages are present,\n     * an exception is thrown.\n     */\n    $log.assertEmpty = function() {\n      var errors = [];\n      angular.forEach(['error', 'warn', 'info', 'log', 'debug'], function(logLevel) {\n        angular.forEach($log[logLevel].logs, function(log) {\n          angular.forEach(log, function(logItem) {\n            errors.push('MOCK $log (' + logLevel + '): ' + String(logItem) + '\\n' +\n                        (logItem.stack || ''));\n          });\n        });\n      });\n      if (errors.length) {\n        errors.unshift('Expected $log to be empty! Either a message was logged unexpectedly, or ' +\n          'an expected log message was not checked and removed:');\n        errors.push('');\n        throw new Error(errors.join('\\n---------\\n'));\n      }\n    };\n\n    $log.reset();\n    return $log;\n  };\n};\n\n\n/**\n * @ngdoc service\n * @name $interval\n *\n * @description\n * Mock implementation of the $interval service.\n *\n * Use {@link ngMock.$interval#flush `$interval.flush(millis)`} to\n * move forward by `millis` milliseconds and trigger any functions scheduled to run in that\n * time.\n *\n * @param {function()} fn A function that should be called repeatedly.\n * @param {number} delay Number of milliseconds between each function call.\n * @param {number=} [count=0] Number of times to repeat. If not set, or 0, will repeat\n *   indefinitely.\n * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise\n *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply $apply} block.\n * @param {...*=} Pass additional parameters to the executed function.\n * @returns {promise} A promise which will be notified on each iteration.\n */\nangular.mock.$IntervalProvider = function() {\n  this.$get = ['$browser', '$rootScope', '$q', '$$q',\n       function($browser,   $rootScope,   $q,   $$q) {\n    var repeatFns = [],\n        nextRepeatId = 0,\n        now = 0;\n\n    var $interval = function(fn, delay, count, invokeApply) {\n      var hasParams = arguments.length > 4,\n          args = hasParams ? Array.prototype.slice.call(arguments, 4) : [],\n          iteration = 0,\n          skipApply = (angular.isDefined(invokeApply) && !invokeApply),\n          deferred = (skipApply ? $$q : $q).defer(),\n          promise = deferred.promise;\n\n      count = (angular.isDefined(count)) ? count : 0;\n      promise.then(null, function() {}, (!hasParams) ? fn : function() {\n        fn.apply(null, args);\n      });\n\n      promise.$$intervalId = nextRepeatId;\n\n      function tick() {\n        deferred.notify(iteration++);\n\n        if (count > 0 && iteration >= count) {\n          var fnIndex;\n          deferred.resolve(iteration);\n\n          angular.forEach(repeatFns, function(fn, index) {\n            if (fn.id === promise.$$intervalId) fnIndex = index;\n          });\n\n          if (angular.isDefined(fnIndex)) {\n            repeatFns.splice(fnIndex, 1);\n          }\n        }\n\n        if (skipApply) {\n          $browser.defer.flush();\n        } else {\n          $rootScope.$apply();\n        }\n      }\n\n      repeatFns.push({\n        nextTime: (now + (delay || 0)),\n        delay: delay || 1,\n        fn: tick,\n        id: nextRepeatId,\n        deferred: deferred\n      });\n      repeatFns.sort(function(a, b) { return a.nextTime - b.nextTime;});\n\n      nextRepeatId++;\n      return promise;\n    };\n    /**\n     * @ngdoc method\n     * @name $interval#cancel\n     *\n     * @description\n     * Cancels a task associated with the `promise`.\n     *\n     * @param {promise} promise A promise from calling the `$interval` function.\n     * @returns {boolean} Returns `true` if the task was successfully cancelled.\n     */\n    $interval.cancel = function(promise) {\n      if (!promise) return false;\n      var fnIndex;\n\n      angular.forEach(repeatFns, function(fn, index) {\n        if (fn.id === promise.$$intervalId) fnIndex = index;\n      });\n\n      if (angular.isDefined(fnIndex)) {\n        repeatFns[fnIndex].deferred.promise.then(undefined, function() {});\n        repeatFns[fnIndex].deferred.reject('canceled');\n        repeatFns.splice(fnIndex, 1);\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * @ngdoc method\n     * @name $interval#flush\n     * @description\n     *\n     * Runs interval tasks scheduled to be run in the next `millis` milliseconds.\n     *\n     * @param {number=} millis maximum timeout amount to flush up until.\n     *\n     * @return {number} The amount of time moved forward.\n     */\n    $interval.flush = function(millis) {\n      var before = now;\n      now += millis;\n      while (repeatFns.length && repeatFns[0].nextTime <= now) {\n        var task = repeatFns[0];\n        task.fn();\n        if (task.nextTime === before) {\n          // this can only happen the first time\n          // a zero-delay interval gets triggered\n          task.nextTime++;\n        }\n        task.nextTime += task.delay;\n        repeatFns.sort(function(a, b) { return a.nextTime - b.nextTime;});\n      }\n      return millis;\n    };\n\n    return $interval;\n  }];\n};\n\n\nfunction jsonStringToDate(string) {\n  // The R_ISO8061_STR regex is never going to fit into the 100 char limit!\n  // eslit-disable-next-line max-len\n  var R_ISO8061_STR = /^(-?\\d{4})-?(\\d\\d)-?(\\d\\d)(?:T(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:\\.(\\d{3}))?)?)?(Z|([+-])(\\d\\d):?(\\d\\d)))?$/;\n\n  var match;\n  if ((match = string.match(R_ISO8061_STR))) {\n    var date = new Date(0),\n        tzHour = 0,\n        tzMin  = 0;\n    if (match[9]) {\n      tzHour = toInt(match[9] + match[10]);\n      tzMin = toInt(match[9] + match[11]);\n    }\n    date.setUTCFullYear(toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));\n    date.setUTCHours(toInt(match[4] || 0) - tzHour,\n                     toInt(match[5] || 0) - tzMin,\n                     toInt(match[6] || 0),\n                     toInt(match[7] || 0));\n    return date;\n  }\n  return string;\n}\n\nfunction toInt(str) {\n  return parseInt(str, 10);\n}\n\nfunction padNumberInMock(num, digits, trim) {\n  var neg = '';\n  if (num < 0) {\n    neg =  '-';\n    num = -num;\n  }\n  num = '' + num;\n  while (num.length < digits) num = '0' + num;\n  if (trim) {\n    num = num.substr(num.length - digits);\n  }\n  return neg + num;\n}\n\n\n/**\n * @ngdoc type\n * @name angular.mock.TzDate\n * @description\n *\n * *NOTE*: this is not an injectable instance, just a globally available mock class of `Date`.\n *\n * Mock of the Date type which has its timezone specified via constructor arg.\n *\n * The main purpose is to create Date-like instances with timezone fixed to the specified timezone\n * offset, so that we can test code that depends on local timezone settings without dependency on\n * the time zone settings of the machine where the code is running.\n *\n * @param {number} offset Offset of the *desired* timezone in hours (fractions will be honored)\n * @param {(number|string)} timestamp Timestamp representing the desired time in *UTC*\n *\n * @example\n * !!!! WARNING !!!!!\n * This is not a complete Date object so only methods that were implemented can be called safely.\n * To make matters worse, TzDate instances inherit stuff from Date via a prototype.\n *\n * We do our best to intercept calls to \"unimplemented\" methods, but since the list of methods is\n * incomplete we might be missing some non-standard methods. This can result in errors like:\n * \"Date.prototype.foo called on incompatible Object\".\n *\n * ```js\n * var newYearInBratislava = new TzDate(-1, '2009-12-31T23:00:00Z');\n * newYearInBratislava.getTimezoneOffset() => -60;\n * newYearInBratislava.getFullYear() => 2010;\n * newYearInBratislava.getMonth() => 0;\n * newYearInBratislava.getDate() => 1;\n * newYearInBratislava.getHours() => 0;\n * newYearInBratislava.getMinutes() => 0;\n * newYearInBratislava.getSeconds() => 0;\n * ```\n *\n */\nangular.mock.TzDate = function(offset, timestamp) {\n  var self = new Date(0);\n  if (angular.isString(timestamp)) {\n    var tsStr = timestamp;\n\n    self.origDate = jsonStringToDate(timestamp);\n\n    timestamp = self.origDate.getTime();\n    if (isNaN(timestamp)) {\n      // eslint-disable-next-line no-throw-literal\n      throw {\n        name: 'Illegal Argument',\n        message: 'Arg \\'' + tsStr + '\\' passed into TzDate constructor is not a valid date string'\n      };\n    }\n  } else {\n    self.origDate = new Date(timestamp);\n  }\n\n  var localOffset = new Date(timestamp).getTimezoneOffset();\n  self.offsetDiff = localOffset * 60 * 1000 - offset * 1000 * 60 * 60;\n  self.date = new Date(timestamp + self.offsetDiff);\n\n  self.getTime = function() {\n    return self.date.getTime() - self.offsetDiff;\n  };\n\n  self.toLocaleDateString = function() {\n    return self.date.toLocaleDateString();\n  };\n\n  self.getFullYear = function() {\n    return self.date.getFullYear();\n  };\n\n  self.getMonth = function() {\n    return self.date.getMonth();\n  };\n\n  self.getDate = function() {\n    return self.date.getDate();\n  };\n\n  self.getHours = function() {\n    return self.date.getHours();\n  };\n\n  self.getMinutes = function() {\n    return self.date.getMinutes();\n  };\n\n  self.getSeconds = function() {\n    return self.date.getSeconds();\n  };\n\n  self.getMilliseconds = function() {\n    return self.date.getMilliseconds();\n  };\n\n  self.getTimezoneOffset = function() {\n    return offset * 60;\n  };\n\n  self.getUTCFullYear = function() {\n    return self.origDate.getUTCFullYear();\n  };\n\n  self.getUTCMonth = function() {\n    return self.origDate.getUTCMonth();\n  };\n\n  self.getUTCDate = function() {\n    return self.origDate.getUTCDate();\n  };\n\n  self.getUTCHours = function() {\n    return self.origDate.getUTCHours();\n  };\n\n  self.getUTCMinutes = function() {\n    return self.origDate.getUTCMinutes();\n  };\n\n  self.getUTCSeconds = function() {\n    return self.origDate.getUTCSeconds();\n  };\n\n  self.getUTCMilliseconds = function() {\n    return self.origDate.getUTCMilliseconds();\n  };\n\n  self.getDay = function() {\n    return self.date.getDay();\n  };\n\n  // provide this method only on browsers that already have it\n  if (self.toISOString) {\n    self.toISOString = function() {\n      return padNumberInMock(self.origDate.getUTCFullYear(), 4) + '-' +\n            padNumberInMock(self.origDate.getUTCMonth() + 1, 2) + '-' +\n            padNumberInMock(self.origDate.getUTCDate(), 2) + 'T' +\n            padNumberInMock(self.origDate.getUTCHours(), 2) + ':' +\n            padNumberInMock(self.origDate.getUTCMinutes(), 2) + ':' +\n            padNumberInMock(self.origDate.getUTCSeconds(), 2) + '.' +\n            padNumberInMock(self.origDate.getUTCMilliseconds(), 3) + 'Z';\n    };\n  }\n\n  //hide all methods not implemented in this mock that the Date prototype exposes\n  var unimplementedMethods = ['getUTCDay',\n      'getYear', 'setDate', 'setFullYear', 'setHours', 'setMilliseconds',\n      'setMinutes', 'setMonth', 'setSeconds', 'setTime', 'setUTCDate', 'setUTCFullYear',\n      'setUTCHours', 'setUTCMilliseconds', 'setUTCMinutes', 'setUTCMonth', 'setUTCSeconds',\n      'setYear', 'toDateString', 'toGMTString', 'toJSON', 'toLocaleFormat', 'toLocaleString',\n      'toLocaleTimeString', 'toSource', 'toString', 'toTimeString', 'toUTCString', 'valueOf'];\n\n  angular.forEach(unimplementedMethods, function(methodName) {\n    self[methodName] = function() {\n      throw new Error('Method \\'' + methodName + '\\' is not implemented in the TzDate mock');\n    };\n  });\n\n  return self;\n};\n\n//make \"tzDateInstance instanceof Date\" return true\nangular.mock.TzDate.prototype = Date.prototype;\n\n\n/**\n * @ngdoc service\n * @name $animate\n *\n * @description\n * Mock implementation of the {@link ng.$animate `$animate`} service. Exposes two additional methods\n * for testing animations.\n *\n * You need to require the `ngAnimateMock` module in your test suite for instance `beforeEach(module('ngAnimateMock'))`\n */\nangular.mock.animate = angular.module('ngAnimateMock', ['ng'])\n  .info({ angularVersion: '1.6.6' })\n\n  .config(['$provide', function($provide) {\n\n    $provide.factory('$$forceReflow', function() {\n      function reflowFn() {\n        reflowFn.totalReflows++;\n      }\n      reflowFn.totalReflows = 0;\n      return reflowFn;\n    });\n\n    $provide.factory('$$animateAsyncRun', function() {\n      var queue = [];\n      var queueFn = function() {\n        return function(fn) {\n          queue.push(fn);\n        };\n      };\n      queueFn.flush = function() {\n        if (queue.length === 0) return false;\n\n        for (var i = 0; i < queue.length; i++) {\n          queue[i]();\n        }\n        queue = [];\n\n        return true;\n      };\n      return queueFn;\n    });\n\n    $provide.decorator('$$animateJs', ['$delegate', function($delegate) {\n      var runners = [];\n\n      var animateJsConstructor = function() {\n        var animator = $delegate.apply($delegate, arguments);\n        // If no javascript animation is found, animator is undefined\n        if (animator) {\n          runners.push(animator);\n        }\n        return animator;\n      };\n\n      animateJsConstructor.$closeAndFlush = function() {\n        runners.forEach(function(runner) {\n          runner.end();\n        });\n        runners = [];\n      };\n\n      return animateJsConstructor;\n    }]);\n\n    $provide.decorator('$animateCss', ['$delegate', function($delegate) {\n      var runners = [];\n\n      var animateCssConstructor = function(element, options) {\n        var animator = $delegate(element, options);\n        runners.push(animator);\n        return animator;\n      };\n\n      animateCssConstructor.$closeAndFlush = function() {\n        runners.forEach(function(runner) {\n          runner.end();\n        });\n        runners = [];\n      };\n\n      return animateCssConstructor;\n    }]);\n\n    $provide.decorator('$animate', ['$delegate', '$timeout', '$browser', '$$rAF', '$animateCss', '$$animateJs',\n                                    '$$forceReflow', '$$animateAsyncRun', '$rootScope',\n                            function($delegate,   $timeout,   $browser,   $$rAF,   $animateCss,   $$animateJs,\n                                     $$forceReflow,   $$animateAsyncRun,  $rootScope) {\n      var animate = {\n        queue: [],\n        cancel: $delegate.cancel,\n        on: $delegate.on,\n        off: $delegate.off,\n        pin: $delegate.pin,\n        get reflows() {\n          return $$forceReflow.totalReflows;\n        },\n        enabled: $delegate.enabled,\n        /**\n         * @ngdoc method\n         * @name $animate#closeAndFlush\n         * @description\n         *\n         * This method will close all pending animations (both {@link ngAnimate#javascript-based-animations Javascript}\n         * and {@link ngAnimate.$animateCss CSS}) and it will also flush any remaining animation frames and/or callbacks.\n         */\n        closeAndFlush: function() {\n          // we allow the flush command to swallow the errors\n          // because depending on whether CSS or JS animations are\n          // used, there may not be a RAF flush. The primary flush\n          // at the end of this function must throw an exception\n          // because it will track if there were pending animations\n          this.flush(true);\n          $animateCss.$closeAndFlush();\n          $$animateJs.$closeAndFlush();\n          this.flush();\n        },\n        /**\n         * @ngdoc method\n         * @name $animate#flush\n         * @description\n         *\n         * This method is used to flush the pending callbacks and animation frames to either start\n         * an animation or conclude an animation. Note that this will not actually close an\n         * actively running animation (see {@link ngMock.$animate#closeAndFlush `closeAndFlush()`} for that).\n         */\n        flush: function(hideErrors) {\n          $rootScope.$digest();\n\n          var doNextRun, somethingFlushed = false;\n          do {\n            doNextRun = false;\n\n            if ($$rAF.queue.length) {\n              $$rAF.flush();\n              doNextRun = somethingFlushed = true;\n            }\n\n            if ($$animateAsyncRun.flush()) {\n              doNextRun = somethingFlushed = true;\n            }\n          } while (doNextRun);\n\n          if (!somethingFlushed && !hideErrors) {\n            throw new Error('No pending animations ready to be closed or flushed');\n          }\n\n          $rootScope.$digest();\n        }\n      };\n\n      angular.forEach(\n        ['animate','enter','leave','move','addClass','removeClass','setClass'], function(method) {\n        animate[method] = function() {\n          animate.queue.push({\n            event: method,\n            element: arguments[0],\n            options: arguments[arguments.length - 1],\n            args: arguments\n          });\n          return $delegate[method].apply($delegate, arguments);\n        };\n      });\n\n      return animate;\n    }]);\n\n  }]);\n\n\n/**\n * @ngdoc function\n * @name angular.mock.dump\n * @description\n *\n * *NOTE*: This is not an injectable instance, just a globally available function.\n *\n * Method for serializing common angular objects (scope, elements, etc..) into strings.\n * It is useful for logging objects to the console when debugging.\n *\n * @param {*} object - any object to turn into string.\n * @return {string} a serialized string of the argument\n */\nangular.mock.dump = function(object) {\n  return serialize(object);\n\n  function serialize(object) {\n    var out;\n\n    if (angular.isElement(object)) {\n      object = angular.element(object);\n      out = angular.element('<div></div>');\n      angular.forEach(object, function(element) {\n        out.append(angular.element(element).clone());\n      });\n      out = out.html();\n    } else if (angular.isArray(object)) {\n      out = [];\n      angular.forEach(object, function(o) {\n        out.push(serialize(o));\n      });\n      out = '[ ' + out.join(', ') + ' ]';\n    } else if (angular.isObject(object)) {\n      if (angular.isFunction(object.$eval) && angular.isFunction(object.$apply)) {\n        out = serializeScope(object);\n      } else if (object instanceof Error) {\n        out = object.stack || ('' + object.name + ': ' + object.message);\n      } else {\n        // TODO(i): this prevents methods being logged,\n        // we should have a better way to serialize objects\n        out = angular.toJson(object, true);\n      }\n    } else {\n      out = String(object);\n    }\n\n    return out;\n  }\n\n  function serializeScope(scope, offset) {\n    offset = offset ||  '  ';\n    var log = [offset + 'Scope(' + scope.$id + '): {'];\n    for (var key in scope) {\n      if (Object.prototype.hasOwnProperty.call(scope, key) && !key.match(/^(\\$|this)/)) {\n        log.push('  ' + key + ': ' + angular.toJson(scope[key]));\n      }\n    }\n    var child = scope.$$childHead;\n    while (child) {\n      log.push(serializeScope(child, offset + '  '));\n      child = child.$$nextSibling;\n    }\n    log.push('}');\n    return log.join('\\n' + offset);\n  }\n};\n\n/**\n * @ngdoc service\n * @name $httpBackend\n * @description\n * Fake HTTP backend implementation suitable for unit testing applications that use the\n * {@link ng.$http $http service}.\n *\n * <div class=\"alert alert-info\">\n * **Note**: For fake HTTP backend implementation suitable for end-to-end testing or backend-less\n * development please see {@link ngMockE2E.$httpBackend e2e $httpBackend mock}.\n * </div>\n *\n * During unit testing, we want our unit tests to run quickly and have no external dependencies so\n * we dont want to send [XHR](https://developer.mozilla.org/en/xmlhttprequest) or\n * [JSONP](http://en.wikipedia.org/wiki/JSONP) requests to a real server. All we really need is\n * to verify whether a certain request has been sent or not, or alternatively just let the\n * application make requests, respond with pre-trained responses and assert that the end result is\n * what we expect it to be.\n *\n * This mock implementation can be used to respond with static or dynamic responses via the\n * `expect` and `when` apis and their shortcuts (`expectGET`, `whenPOST`, etc).\n *\n * When an Angular application needs some data from a server, it calls the $http service, which\n * sends the request to a real server using $httpBackend service. With dependency injection, it is\n * easy to inject $httpBackend mock (which has the same API as $httpBackend) and use it to verify\n * the requests and respond with some testing data without sending a request to a real server.\n *\n * There are two ways to specify what test data should be returned as http responses by the mock\n * backend when the code under test makes http requests:\n *\n * - `$httpBackend.expect` - specifies a request expectation\n * - `$httpBackend.when` - specifies a backend definition\n *\n *\n * ## Request Expectations vs Backend Definitions\n *\n * Request expectations provide a way to make assertions about requests made by the application and\n * to define responses for those requests. The test will fail if the expected requests are not made\n * or they are made in the wrong order.\n *\n * Backend definitions allow you to define a fake backend for your application which doesn't assert\n * if a particular request was made or not, it just returns a trained response if a request is made.\n * The test will pass whether or not the request gets made during testing.\n *\n *\n * <table class=\"table\">\n *   <tr><th width=\"220px\"></th><th>Request expectations</th><th>Backend definitions</th></tr>\n *   <tr>\n *     <th>Syntax</th>\n *     <td>.expect(...).respond(...)</td>\n *     <td>.when(...).respond(...)</td>\n *   </tr>\n *   <tr>\n *     <th>Typical usage</th>\n *     <td>strict unit tests</td>\n *     <td>loose (black-box) unit testing</td>\n *   </tr>\n *   <tr>\n *     <th>Fulfills multiple requests</th>\n *     <td>NO</td>\n *     <td>YES</td>\n *   </tr>\n *   <tr>\n *     <th>Order of requests matters</th>\n *     <td>YES</td>\n *     <td>NO</td>\n *   </tr>\n *   <tr>\n *     <th>Request required</th>\n *     <td>YES</td>\n *     <td>NO</td>\n *   </tr>\n *   <tr>\n *     <th>Response required</th>\n *     <td>optional (see below)</td>\n *     <td>YES</td>\n *   </tr>\n * </table>\n *\n * In cases where both backend definitions and request expectations are specified during unit\n * testing, the request expectations are evaluated first.\n *\n * If a request expectation has no response specified, the algorithm will search your backend\n * definitions for an appropriate response.\n *\n * If a request didn't match any expectation or if the expectation doesn't have the response\n * defined, the backend definitions are evaluated in sequential order to see if any of them match\n * the request. The response from the first matched definition is returned.\n *\n *\n * ## Flushing HTTP requests\n *\n * The $httpBackend used in production always responds to requests asynchronously. If we preserved\n * this behavior in unit testing, we'd have to create async unit tests, which are hard to write,\n * to follow and to maintain. But neither can the testing mock respond synchronously; that would\n * change the execution of the code under test. For this reason, the mock $httpBackend has a\n * `flush()` method, which allows the test to explicitly flush pending requests. This preserves\n * the async api of the backend, while allowing the test to execute synchronously.\n *\n *\n * ## Unit testing with mock $httpBackend\n * The following code shows how to setup and use the mock backend when unit testing a controller.\n * First we create the controller under test:\n *\n  ```js\n  // The module code\n  angular\n    .module('MyApp', [])\n    .controller('MyController', MyController);\n\n  // The controller code\n  function MyController($scope, $http) {\n    var authToken;\n\n    $http.get('/auth.py').then(function(response) {\n      authToken = response.headers('A-Token');\n      $scope.user = response.data;\n    }).catch(function() {\n      $scope.status = 'Failed...';\n    });\n\n    $scope.saveMessage = function(message) {\n      var headers = { 'Authorization': authToken };\n      $scope.status = 'Saving...';\n\n      $http.post('/add-msg.py', message, { headers: headers } ).then(function(response) {\n        $scope.status = '';\n      }).catch(function() {\n        $scope.status = 'Failed...';\n      });\n    };\n  }\n  ```\n *\n * Now we setup the mock backend and create the test specs:\n *\n  ```js\n    // testing controller\n    describe('MyController', function() {\n       var $httpBackend, $rootScope, createController, authRequestHandler;\n\n       // Set up the module\n       beforeEach(module('MyApp'));\n\n       beforeEach(inject(function($injector) {\n         // Set up the mock http service responses\n         $httpBackend = $injector.get('$httpBackend');\n         // backend definition common for all tests\n         authRequestHandler = $httpBackend.when('GET', '/auth.py')\n                                .respond({userId: 'userX'}, {'A-Token': 'xxx'});\n\n         // Get hold of a scope (i.e. the root scope)\n         $rootScope = $injector.get('$rootScope');\n         // The $controller service is used to create instances of controllers\n         var $controller = $injector.get('$controller');\n\n         createController = function() {\n           return $controller('MyController', {'$scope' : $rootScope });\n         };\n       }));\n\n\n       afterEach(function() {\n         $httpBackend.verifyNoOutstandingExpectation();\n         $httpBackend.verifyNoOutstandingRequest();\n       });\n\n\n       it('should fetch authentication token', function() {\n         $httpBackend.expectGET('/auth.py');\n         var controller = createController();\n         $httpBackend.flush();\n       });\n\n\n       it('should fail authentication', function() {\n\n         // Notice how you can change the response even after it was set\n         authRequestHandler.respond(401, '');\n\n         $httpBackend.expectGET('/auth.py');\n         var controller = createController();\n         $httpBackend.flush();\n         expect($rootScope.status).toBe('Failed...');\n       });\n\n\n       it('should send msg to server', function() {\n         var controller = createController();\n         $httpBackend.flush();\n\n         // now you dont care about the authentication, but\n         // the controller will still send the request and\n         // $httpBackend will respond without you having to\n         // specify the expectation and response for this request\n\n         $httpBackend.expectPOST('/add-msg.py', 'message content').respond(201, '');\n         $rootScope.saveMessage('message content');\n         expect($rootScope.status).toBe('Saving...');\n         $httpBackend.flush();\n         expect($rootScope.status).toBe('');\n       });\n\n\n       it('should send auth header', function() {\n         var controller = createController();\n         $httpBackend.flush();\n\n         $httpBackend.expectPOST('/add-msg.py', undefined, function(headers) {\n           // check if the header was sent, if it wasn't the expectation won't\n           // match the request and the test will fail\n           return headers['Authorization'] === 'xxx';\n         }).respond(201, '');\n\n         $rootScope.saveMessage('whatever');\n         $httpBackend.flush();\n       });\n    });\n  ```\n *\n * ## Dynamic responses\n *\n * You define a response to a request by chaining a call to `respond()` onto a definition or expectation.\n * If you provide a **callback** as the first parameter to `respond(callback)` then you can dynamically generate\n * a response based on the properties of the request.\n *\n * The `callback` function should be of the form `function(method, url, data, headers, params)`.\n *\n * ### Query parameters\n *\n * By default, query parameters on request URLs are parsed into the `params` object. So a request URL\n * of `/list?q=searchstr&orderby=-name` would set `params` to be `{q: 'searchstr', orderby: '-name'}`.\n *\n * ### Regex parameter matching\n *\n * If an expectation or definition uses a **regex** to match the URL, you can provide an array of **keys** via a\n * `params` argument. The index of each **key** in the array will match the index of a **group** in the\n * **regex**.\n *\n * The `params` object in the **callback** will now have properties with these keys, which hold the value of the\n * corresponding **group** in the **regex**.\n *\n * This also applies to the `when` and `expect` shortcut methods.\n *\n *\n * ```js\n *   $httpBackend.expect('GET', /\\/user\\/(.+)/, undefined, undefined, ['id'])\n *     .respond(function(method, url, data, headers, params) {\n *       // for requested url of '/user/1234' params is {id: '1234'}\n *     });\n *\n *   $httpBackend.whenPATCH(/\\/user\\/(.+)\\/article\\/(.+)/, undefined, undefined, ['user', 'article'])\n *     .respond(function(method, url, data, headers, params) {\n *       // for url of '/user/1234/article/567' params is {user: '1234', article: '567'}\n *     });\n * ```\n *\n * ## Matching route requests\n *\n * For extra convenience, `whenRoute` and `expectRoute` shortcuts are available. These methods offer colon\n * delimited matching of the url path, ignoring the query string. This allows declarations\n * similar to how application routes are configured with `$routeProvider`. Because these methods convert\n * the definition url to regex, declaration order is important. Combined with query parameter parsing,\n * the following is possible:\n *\n  ```js\n    $httpBackend.whenRoute('GET', '/users/:id')\n      .respond(function(method, url, data, headers, params) {\n        return [200, MockUserList[Number(params.id)]];\n      });\n\n    $httpBackend.whenRoute('GET', '/users')\n      .respond(function(method, url, data, headers, params) {\n        var userList = angular.copy(MockUserList),\n          defaultSort = 'lastName',\n          count, pages, isPrevious, isNext;\n\n        // paged api response '/v1/users?page=2'\n        params.page = Number(params.page) || 1;\n\n        // query for last names '/v1/users?q=Archer'\n        if (params.q) {\n          userList = $filter('filter')({lastName: params.q});\n        }\n\n        pages = Math.ceil(userList.length / pagingLength);\n        isPrevious = params.page > 1;\n        isNext = params.page < pages;\n\n        return [200, {\n          count:    userList.length,\n          previous: isPrevious,\n          next:     isNext,\n          // sort field -> '/v1/users?sortBy=firstName'\n          results:  $filter('orderBy')(userList, params.sortBy || defaultSort)\n                      .splice((params.page - 1) * pagingLength, pagingLength)\n        }];\n      });\n  ```\n */\nangular.mock.$httpBackendDecorator =\n  ['$rootScope', '$timeout', '$delegate', createHttpBackendMock];\n\n/**\n * General factory function for $httpBackend mock.\n * Returns instance for unit testing (when no arguments specified):\n *   - passing through is disabled\n *   - auto flushing is disabled\n *\n * Returns instance for e2e testing (when `$delegate` and `$browser` specified):\n *   - passing through (delegating request to real backend) is enabled\n *   - auto flushing is enabled\n *\n * @param {Object=} $delegate Real $httpBackend instance (allow passing through if specified)\n * @param {Object=} $browser Auto-flushing enabled if specified\n * @return {Object} Instance of $httpBackend mock\n */\nfunction createHttpBackendMock($rootScope, $timeout, $delegate, $browser) {\n  var definitions = [],\n      expectations = [],\n      responses = [],\n      responsesPush = angular.bind(responses, responses.push),\n      copy = angular.copy,\n      // We cache the original backend so that if both ngMock and ngMockE2E override the\n      // service the ngMockE2E version can pass through to the real backend\n      originalHttpBackend = $delegate.$$originalHttpBackend || $delegate;\n\n  function createResponse(status, data, headers, statusText) {\n    if (angular.isFunction(status)) return status;\n\n    return function() {\n      return angular.isNumber(status)\n          ? [status, data, headers, statusText, 'complete']\n          : [200, status, data, headers, 'complete'];\n    };\n  }\n\n  // TODO(vojta): change params to: method, url, data, headers, callback\n  function $httpBackend(method, url, data, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {\n\n    var xhr = new MockXhr(),\n        expectation = expectations[0],\n        wasExpected = false;\n\n    xhr.$$events = eventHandlers;\n    xhr.upload.$$events = uploadEventHandlers;\n\n    function prettyPrint(data) {\n      return (angular.isString(data) || angular.isFunction(data) || data instanceof RegExp)\n          ? data\n          : angular.toJson(data);\n    }\n\n    function wrapResponse(wrapped) {\n      if (!$browser && timeout) {\n        if (timeout.then) {\n          timeout.then(handleTimeout);\n        } else {\n          $timeout(handleTimeout, timeout);\n        }\n      }\n\n      handleResponse.description = method + ' ' + url;\n      return handleResponse;\n\n      function handleResponse() {\n        var response = wrapped.response(method, url, data, headers, wrapped.params(url));\n        xhr.$$respHeaders = response[2];\n        callback(copy(response[0]), copy(response[1]), xhr.getAllResponseHeaders(),\n                 copy(response[3] || ''), copy(response[4]));\n      }\n\n      function handleTimeout() {\n        for (var i = 0, ii = responses.length; i < ii; i++) {\n          if (responses[i] === handleResponse) {\n            responses.splice(i, 1);\n            callback(-1, undefined, '', undefined, 'timeout');\n            break;\n          }\n        }\n      }\n    }\n\n    if (expectation && expectation.match(method, url)) {\n      if (!expectation.matchData(data)) {\n        throw new Error('Expected ' + expectation + ' with different data\\n' +\n            'EXPECTED: ' + prettyPrint(expectation.data) + '\\nGOT:      ' + data);\n      }\n\n      if (!expectation.matchHeaders(headers)) {\n        throw new Error('Expected ' + expectation + ' with different headers\\n' +\n                        'EXPECTED: ' + prettyPrint(expectation.headers) + '\\nGOT:      ' +\n                        prettyPrint(headers));\n      }\n\n      expectations.shift();\n\n      if (expectation.response) {\n        responses.push(wrapResponse(expectation));\n        return;\n      }\n      wasExpected = true;\n    }\n\n    var i = -1, definition;\n    while ((definition = definitions[++i])) {\n      if (definition.match(method, url, data, headers || {})) {\n        if (definition.response) {\n          // if $browser specified, we do auto flush all requests\n          ($browser ? $browser.defer : responsesPush)(wrapResponse(definition));\n        } else if (definition.passThrough) {\n          originalHttpBackend(method, url, data, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers);\n        } else throw new Error('No response defined !');\n        return;\n      }\n    }\n    throw wasExpected ?\n        new Error('No response defined !') :\n        new Error('Unexpected request: ' + method + ' ' + url + '\\n' +\n                  (expectation ? 'Expected ' + expectation : 'No more request expected'));\n  }\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#when\n   * @description\n   * Creates a new backend definition.\n   *\n   * @param {string} method HTTP method.\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives\n   *   data string and returns true if the data is as expected.\n   * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header\n   *   object and returns true if the headers match the current definition.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   *   request is handled. You can save this object for later use and invoke `respond` again in\n   *   order to change how a matched request is handled.\n   *\n   *  - respond \n   *      ```js\n   *      {function([status,] data[, headers, statusText])\n   *      | function(function(method, url, data, headers, params)}\n   *      ```\n   *     The respond method takes a set of static data to be returned or a function that can\n   *    return an array containing response status (number), response data (Array|Object|string),\n   *    response headers (Object), and the text for the status (string). The respond method returns\n   *    the `requestHandler` object for possible overrides.\n   */\n  $httpBackend.when = function(method, url, data, headers, keys) {\n\n    assertArgDefined(arguments, 1, 'url');\n\n    var definition = new MockHttpExpectation(method, url, data, headers, keys),\n        chain = {\n          respond: function(status, data, headers, statusText) {\n            definition.passThrough = undefined;\n            definition.response = createResponse(status, data, headers, statusText);\n            return chain;\n          }\n        };\n\n    if ($browser) {\n      chain.passThrough = function() {\n        definition.response = undefined;\n        definition.passThrough = true;\n        return chain;\n      };\n    }\n\n    definitions.push(definition);\n    return chain;\n  };\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#whenGET\n   * @description\n   * Creates a new backend definition for GET requests. For more info see `when()`.\n   *\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {(Object|function(Object))=} headers HTTP headers.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   * request is handled. You can save this object for later use and invoke `respond` again in\n   * order to change how a matched request is handled.\n   */\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#whenHEAD\n   * @description\n   * Creates a new backend definition for HEAD requests. For more info see `when()`.\n   *\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {(Object|function(Object))=} headers HTTP headers.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   * request is handled. You can save this object for later use and invoke `respond` again in\n   * order to change how a matched request is handled.\n   */\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#whenDELETE\n   * @description\n   * Creates a new backend definition for DELETE requests. For more info see `when()`.\n   *\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {(Object|function(Object))=} headers HTTP headers.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   * request is handled. You can save this object for later use and invoke `respond` again in\n   * order to change how a matched request is handled.\n   */\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#whenPOST\n   * @description\n   * Creates a new backend definition for POST requests. For more info see `when()`.\n   *\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives\n   *   data string and returns true if the data is as expected.\n   * @param {(Object|function(Object))=} headers HTTP headers.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   * request is handled. You can save this object for later use and invoke `respond` again in\n   * order to change how a matched request is handled.\n   */\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#whenPUT\n   * @description\n   * Creates a new backend definition for PUT requests.  For more info see `when()`.\n   *\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives\n   *   data string and returns true if the data is as expected.\n   * @param {(Object|function(Object))=} headers HTTP headers.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   * request is handled. You can save this object for later use and invoke `respond` again in\n   * order to change how a matched request is handled.\n   */\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#whenJSONP\n   * @description\n   * Creates a new backend definition for JSONP requests. For more info see `when()`.\n   *\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   * request is handled. You can save this object for later use and invoke `respond` again in\n   * order to change how a matched request is handled.\n   */\n  createShortMethods('when');\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#whenRoute\n   * @description\n   * Creates a new backend definition that compares only with the requested route.\n   *\n   * @param {string} method HTTP method.\n   * @param {string} url HTTP url string that supports colon param matching.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   * request is handled. You can save this object for later use and invoke `respond` again in\n   * order to change how a matched request is handled. See #when for more info.\n   */\n  $httpBackend.whenRoute = function(method, url) {\n    var pathObj = parseRoute(url);\n    return $httpBackend.when(method, pathObj.regexp, undefined, undefined, pathObj.keys);\n  };\n\n  function parseRoute(url) {\n    var ret = {\n      regexp: url\n    },\n    keys = ret.keys = [];\n\n    if (!url || !angular.isString(url)) return ret;\n\n    url = url\n      .replace(/([().])/g, '\\\\$1')\n      .replace(/(\\/)?:(\\w+)([?*])?/g, function(_, slash, key, option) {\n        var optional = option === '?' ? option : null;\n        var star = option === '*' ? option : null;\n        keys.push({ name: key, optional: !!optional });\n        slash = slash || '';\n        return ''\n          + (optional ? '' : slash)\n          + '(?:'\n          + (optional ? slash : '')\n          + (star && '(.+?)' || '([^/]+)')\n          + (optional || '')\n          + ')'\n          + (optional || '');\n      })\n      .replace(/([/$*])/g, '\\\\$1');\n\n    ret.regexp = new RegExp('^' + url, 'i');\n    return ret;\n  }\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#expect\n   * @description\n   * Creates a new request expectation.\n   *\n   * @param {string} method HTTP method.\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that\n   *  receives data string and returns true if the data is as expected, or Object if request body\n   *  is in JSON format.\n   * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header\n   *   object and returns true if the headers match the current expectation.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   *  request is handled. You can save this object for later use and invoke `respond` again in\n   *  order to change how a matched request is handled.\n   *\n   *  - respond \n   *    ```\n   *    { function([status,] data[, headers, statusText])\n   *    | function(function(method, url, data, headers, params)}\n   *    ```\n   *     The respond method takes a set of static data to be returned or a function that can\n   *    return an array containing response status (number), response data (Array|Object|string),\n   *    response headers (Object), and the text for the status (string). The respond method returns\n   *    the `requestHandler` object for possible overrides.\n   */\n  $httpBackend.expect = function(method, url, data, headers, keys) {\n\n    assertArgDefined(arguments, 1, 'url');\n\n    var expectation = new MockHttpExpectation(method, url, data, headers, keys),\n        chain = {\n          respond: function(status, data, headers, statusText) {\n            expectation.response = createResponse(status, data, headers, statusText);\n            return chain;\n          }\n        };\n\n    expectations.push(expectation);\n    return chain;\n  };\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#expectGET\n   * @description\n   * Creates a new request expectation for GET requests. For more info see `expect()`.\n   *\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {Object=} headers HTTP headers.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   * request is handled. You can save this object for later use and invoke `respond` again in\n   * order to change how a matched request is handled. See #expect for more info.\n   */\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#expectHEAD\n   * @description\n   * Creates a new request expectation for HEAD requests. For more info see `expect()`.\n   *\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {Object=} headers HTTP headers.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   *   request is handled. You can save this object for later use and invoke `respond` again in\n   *   order to change how a matched request is handled.\n   */\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#expectDELETE\n   * @description\n   * Creates a new request expectation for DELETE requests. For more info see `expect()`.\n   *\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {Object=} headers HTTP headers.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   *   request is handled. You can save this object for later use and invoke `respond` again in\n   *   order to change how a matched request is handled.\n   */\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#expectPOST\n   * @description\n   * Creates a new request expectation for POST requests. For more info see `expect()`.\n   *\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that\n   *  receives data string and returns true if the data is as expected, or Object if request body\n   *  is in JSON format.\n   * @param {Object=} headers HTTP headers.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   *   request is handled. You can save this object for later use and invoke `respond` again in\n   *   order to change how a matched request is handled.\n   */\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#expectPUT\n   * @description\n   * Creates a new request expectation for PUT requests. For more info see `expect()`.\n   *\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that\n   *  receives data string and returns true if the data is as expected, or Object if request body\n   *  is in JSON format.\n   * @param {Object=} headers HTTP headers.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   *   request is handled. You can save this object for later use and invoke `respond` again in\n   *   order to change how a matched request is handled.\n   */\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#expectPATCH\n   * @description\n   * Creates a new request expectation for PATCH requests. For more info see `expect()`.\n   *\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that\n   *  receives data string and returns true if the data is as expected, or Object if request body\n   *  is in JSON format.\n   * @param {Object=} headers HTTP headers.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   *   request is handled. You can save this object for later use and invoke `respond` again in\n   *   order to change how a matched request is handled.\n   */\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#expectJSONP\n   * @description\n   * Creates a new request expectation for JSONP requests. For more info see `expect()`.\n   *\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives an url\n   *   and returns true if the url matches the current definition.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   *   request is handled. You can save this object for later use and invoke `respond` again in\n   *   order to change how a matched request is handled.\n   */\n  createShortMethods('expect');\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#expectRoute\n   * @description\n   * Creates a new request expectation that compares only with the requested route.\n   *\n   * @param {string} method HTTP method.\n   * @param {string} url HTTP url string that supports colon param matching.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   * request is handled. You can save this object for later use and invoke `respond` again in\n   * order to change how a matched request is handled. See #expect for more info.\n   */\n  $httpBackend.expectRoute = function(method, url) {\n    var pathObj = parseRoute(url);\n    return $httpBackend.expect(method, pathObj.regexp, undefined, undefined, pathObj.keys);\n  };\n\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#flush\n   * @description\n   * Flushes pending requests using the trained responses. Requests are flushed in the order they\n   * were made, but it is also possible to skip one or more requests (for example to have them\n   * flushed later). This is useful for simulating scenarios where responses arrive from the server\n   * in any order.\n   *\n   * If there are no pending requests to flush when the method is called, an exception is thrown (as\n   * this is typically a sign of programming error).\n   *\n   * @param {number=} count - Number of responses to flush. If undefined/null, all pending requests\n   *     (starting after `skip`) will be flushed.\n   * @param {number=} [skip=0] - Number of pending requests to skip. For example, a value of `5`\n   *     would skip the first 5 pending requests and start flushing from the 6th onwards.\n   */\n  $httpBackend.flush = function(count, skip, digest) {\n    if (digest !== false) $rootScope.$digest();\n\n    skip = skip || 0;\n    if (skip >= responses.length) throw new Error('No pending request to flush !');\n\n    if (angular.isDefined(count) && count !== null) {\n      while (count--) {\n        var part = responses.splice(skip, 1);\n        if (!part.length) throw new Error('No more pending request to flush !');\n        part[0]();\n      }\n    } else {\n      while (responses.length > skip) {\n        responses.splice(skip, 1)[0]();\n      }\n    }\n    $httpBackend.verifyNoOutstandingExpectation(digest);\n  };\n\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#verifyNoOutstandingExpectation\n   * @description\n   * Verifies that all of the requests defined via the `expect` api were made. If any of the\n   * requests were not made, verifyNoOutstandingExpectation throws an exception.\n   *\n   * Typically, you would call this method following each test case that asserts requests using an\n   * \"afterEach\" clause.\n   *\n   * ```js\n   *   afterEach($httpBackend.verifyNoOutstandingExpectation);\n   * ```\n   */\n  $httpBackend.verifyNoOutstandingExpectation = function(digest) {\n    if (digest !== false) $rootScope.$digest();\n    if (expectations.length) {\n      throw new Error('Unsatisfied requests: ' + expectations.join(', '));\n    }\n  };\n\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#verifyNoOutstandingRequest\n   * @description\n   * Verifies that there are no outstanding requests that need to be flushed.\n   *\n   * Typically, you would call this method following each test case that asserts requests using an\n   * \"afterEach\" clause.\n   *\n   * ```js\n   *   afterEach($httpBackend.verifyNoOutstandingRequest);\n   * ```\n   */\n  $httpBackend.verifyNoOutstandingRequest = function(digest) {\n    if (digest !== false) $rootScope.$digest();\n    if (responses.length) {\n      var unflushedDescriptions = responses.map(function(res) { return res.description; });\n      throw new Error('Unflushed requests: ' + responses.length + '\\n  ' +\n                      unflushedDescriptions.join('\\n  '));\n    }\n  };\n\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#resetExpectations\n   * @description\n   * Resets all request expectations, but preserves all backend definitions. Typically, you would\n   * call resetExpectations during a multiple-phase test when you want to reuse the same instance of\n   * $httpBackend mock.\n   */\n  $httpBackend.resetExpectations = function() {\n    expectations.length = 0;\n    responses.length = 0;\n  };\n\n  $httpBackend.$$originalHttpBackend = originalHttpBackend;\n\n  return $httpBackend;\n\n\n  function createShortMethods(prefix) {\n    angular.forEach(['GET', 'DELETE', 'JSONP', 'HEAD'], function(method) {\n     $httpBackend[prefix + method] = function(url, headers, keys) {\n        assertArgDefined(arguments, 0, 'url');\n\n        // Change url to `null` if `undefined` to stop it throwing an exception further down\n        if (angular.isUndefined(url)) url = null;\n\n       return $httpBackend[prefix](method, url, undefined, headers, keys);\n     };\n    });\n\n    angular.forEach(['PUT', 'POST', 'PATCH'], function(method) {\n      $httpBackend[prefix + method] = function(url, data, headers, keys) {\n        assertArgDefined(arguments, 0, 'url');\n\n        // Change url to `null` if `undefined` to stop it throwing an exception further down\n        if (angular.isUndefined(url)) url = null;\n\n        return $httpBackend[prefix](method, url, data, headers, keys);\n      };\n    });\n  }\n}\n\nfunction assertArgDefined(args, index, name) {\n  if (args.length > index && angular.isUndefined(args[index])) {\n    throw new Error('Undefined argument `' + name + '`; the argument is provided but not defined');\n  }\n}\n\n\nfunction MockHttpExpectation(method, url, data, headers, keys) {\n\n  function getUrlParams(u) {\n    var params = u.slice(u.indexOf('?') + 1).split('&');\n    return params.sort();\n  }\n\n  function compareUrl(u) {\n    return (url.slice(0, url.indexOf('?')) === u.slice(0, u.indexOf('?')) &&\n      getUrlParams(url).join() === getUrlParams(u).join());\n  }\n\n  this.data = data;\n  this.headers = headers;\n\n  this.match = function(m, u, d, h) {\n    if (method !== m) return false;\n    if (!this.matchUrl(u)) return false;\n    if (angular.isDefined(d) && !this.matchData(d)) return false;\n    if (angular.isDefined(h) && !this.matchHeaders(h)) return false;\n    return true;\n  };\n\n  this.matchUrl = function(u) {\n    if (!url) return true;\n    if (angular.isFunction(url.test)) return url.test(u);\n    if (angular.isFunction(url)) return url(u);\n    return (url === u || compareUrl(u));\n  };\n\n  this.matchHeaders = function(h) {\n    if (angular.isUndefined(headers)) return true;\n    if (angular.isFunction(headers)) return headers(h);\n    return angular.equals(headers, h);\n  };\n\n  this.matchData = function(d) {\n    if (angular.isUndefined(data)) return true;\n    if (data && angular.isFunction(data.test)) return data.test(d);\n    if (data && angular.isFunction(data)) return data(d);\n    if (data && !angular.isString(data)) {\n      return angular.equals(angular.fromJson(angular.toJson(data)), angular.fromJson(d));\n    }\n    // eslint-disable-next-line eqeqeq\n    return data == d;\n  };\n\n  this.toString = function() {\n    return method + ' ' + url;\n  };\n\n  this.params = function(u) {\n    return angular.extend(parseQuery(), pathParams());\n\n    function pathParams() {\n      var keyObj = {};\n      if (!url || !angular.isFunction(url.test) || !keys || keys.length === 0) return keyObj;\n\n      var m = url.exec(u);\n      if (!m) return keyObj;\n      for (var i = 1, len = m.length; i < len; ++i) {\n        var key = keys[i - 1];\n        var val = m[i];\n        if (key && val) {\n          keyObj[key.name || key] = val;\n        }\n      }\n\n      return keyObj;\n    }\n\n    function parseQuery() {\n      var obj = {}, key_value, key,\n          queryStr = u.indexOf('?') > -1\n          ? u.substring(u.indexOf('?') + 1)\n          : '';\n\n      angular.forEach(queryStr.split('&'), function(keyValue) {\n        if (keyValue) {\n          key_value = keyValue.replace(/\\+/g,'%20').split('=');\n          key = tryDecodeURIComponent(key_value[0]);\n          if (angular.isDefined(key)) {\n            var val = angular.isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;\n            if (!hasOwnProperty.call(obj, key)) {\n              obj[key] = val;\n            } else if (angular.isArray(obj[key])) {\n              obj[key].push(val);\n            } else {\n              obj[key] = [obj[key],val];\n            }\n          }\n        }\n      });\n      return obj;\n    }\n    function tryDecodeURIComponent(value) {\n      try {\n        return decodeURIComponent(value);\n      } catch (e) {\n        // Ignore any invalid uri component\n      }\n    }\n  };\n}\n\nfunction createMockXhr() {\n  return new MockXhr();\n}\n\nfunction MockXhr() {\n\n  // hack for testing $http, $httpBackend\n  MockXhr.$$lastInstance = this;\n\n  this.open = function(method, url, async) {\n    this.$$method = method;\n    this.$$url = url;\n    this.$$async = async;\n    this.$$reqHeaders = {};\n    this.$$respHeaders = {};\n  };\n\n  this.send = function(data) {\n    this.$$data = data;\n  };\n\n  this.setRequestHeader = function(key, value) {\n    this.$$reqHeaders[key] = value;\n  };\n\n  this.getResponseHeader = function(name) {\n    // the lookup must be case insensitive,\n    // that's why we try two quick lookups first and full scan last\n    var header = this.$$respHeaders[name];\n    if (header) return header;\n\n    name = angular.lowercase(name);\n    header = this.$$respHeaders[name];\n    if (header) return header;\n\n    header = undefined;\n    angular.forEach(this.$$respHeaders, function(headerVal, headerName) {\n      if (!header && angular.lowercase(headerName) === name) header = headerVal;\n    });\n    return header;\n  };\n\n  this.getAllResponseHeaders = function() {\n    var lines = [];\n\n    angular.forEach(this.$$respHeaders, function(value, key) {\n      lines.push(key + ': ' + value);\n    });\n    return lines.join('\\n');\n  };\n\n  this.abort = angular.noop;\n\n  // This section simulates the events on a real XHR object (and the upload object)\n  // When we are testing $httpBackend (inside the angular project) we make partial use of this\n  // but store the events directly ourselves on `$$events`, instead of going through the `addEventListener`\n  this.$$events = {};\n  this.addEventListener = function(name, listener) {\n    if (angular.isUndefined(this.$$events[name])) this.$$events[name] = [];\n    this.$$events[name].push(listener);\n  };\n\n  this.upload = {\n    $$events: {},\n    addEventListener: this.addEventListener\n  };\n}\n\n\n/**\n * @ngdoc service\n * @name $timeout\n * @description\n *\n * This service is just a simple decorator for {@link ng.$timeout $timeout} service\n * that adds a \"flush\" and \"verifyNoPendingTasks\" methods.\n */\n\nangular.mock.$TimeoutDecorator = ['$delegate', '$browser', function($delegate, $browser) {\n\n  /**\n   * @ngdoc method\n   * @name $timeout#flush\n   * @description\n   *\n   * Flushes the queue of pending tasks.\n   *\n   * @param {number=} delay maximum timeout amount to flush up until\n   */\n  $delegate.flush = function(delay) {\n    $browser.defer.flush(delay);\n  };\n\n  /**\n   * @ngdoc method\n   * @name $timeout#verifyNoPendingTasks\n   * @description\n   *\n   * Verifies that there are no pending tasks that need to be flushed.\n   */\n  $delegate.verifyNoPendingTasks = function() {\n    if ($browser.deferredFns.length) {\n      throw new Error('Deferred tasks to flush (' + $browser.deferredFns.length + '): ' +\n          formatPendingTasksAsString($browser.deferredFns));\n    }\n  };\n\n  function formatPendingTasksAsString(tasks) {\n    var result = [];\n    angular.forEach(tasks, function(task) {\n      result.push('{id: ' + task.id + ', time: ' + task.time + '}');\n    });\n\n    return result.join(', ');\n  }\n\n  return $delegate;\n}];\n\nangular.mock.$RAFDecorator = ['$delegate', function($delegate) {\n  var rafFn = function(fn) {\n    var index = rafFn.queue.length;\n    rafFn.queue.push(fn);\n    return function() {\n      rafFn.queue.splice(index, 1);\n    };\n  };\n\n  rafFn.queue = [];\n  rafFn.supported = $delegate.supported;\n\n  rafFn.flush = function() {\n    if (rafFn.queue.length === 0) {\n      throw new Error('No rAF callbacks present');\n    }\n\n    var length = rafFn.queue.length;\n    for (var i = 0; i < length; i++) {\n      rafFn.queue[i]();\n    }\n\n    rafFn.queue = rafFn.queue.slice(i);\n  };\n\n  return rafFn;\n}];\n\n/**\n *\n */\nvar originalRootElement;\nangular.mock.$RootElementProvider = function() {\n  this.$get = ['$injector', function($injector) {\n    originalRootElement = angular.element('<div ng-app></div>').data('$injector', $injector);\n    return originalRootElement;\n  }];\n};\n\n/**\n * @ngdoc service\n * @name $controller\n * @description\n * A decorator for {@link ng.$controller} with additional `bindings` parameter, useful when testing\n * controllers of directives that use {@link $compile#-bindtocontroller- `bindToController`}.\n *\n * Depending on the value of\n * {@link ng.$compileProvider#preAssignBindingsEnabled `preAssignBindingsEnabled()`}, the properties\n * will be bound before or after invoking the constructor.\n *\n *\n * ## Example\n *\n * ```js\n *\n * // Directive definition ...\n *\n * myMod.directive('myDirective', {\n *   controller: 'MyDirectiveController',\n *   bindToController: {\n *     name: '@'\n *   }\n * });\n *\n *\n * // Controller definition ...\n *\n * myMod.controller('MyDirectiveController', ['$log', function($log) {\n *   this.log = function() {\n *     $log.info(this.name);\n *   };\n * }]);\n *\n *\n * // In a test ...\n *\n * describe('myDirectiveController', function() {\n *   describe('log()', function() {\n *     it('should write the bound name to the log', inject(function($controller, $log) {\n *       var ctrl = $controller('MyDirectiveController', { /* no locals &#42;/ }, { name: 'Clark Kent' });\n *       ctrl.log();\n *\n *       expect(ctrl.name).toEqual('Clark Kent');\n *       expect($log.info.logs).toEqual(['Clark Kent']);\n *     }));\n *   });\n * });\n *\n * ```\n *\n * @param {Function|string} constructor If called with a function then it's considered to be the\n *    controller constructor function. Otherwise it's considered to be a string which is used\n *    to retrieve the controller constructor using the following steps:\n *\n *    * check if a controller with given name is registered via `$controllerProvider`\n *    * check if evaluating the string on the current scope returns a constructor\n *    * if $controllerProvider#allowGlobals, check `window[constructor]` on the global\n *      `window` object (deprecated, not recommended)\n *\n *    The string can use the `controller as property` syntax, where the controller instance is published\n *    as the specified property on the `scope`; the `scope` must be injected into `locals` param for this\n *    to work correctly.\n *\n * @param {Object} locals Injection locals for Controller.\n * @param {Object=} bindings Properties to add to the controller instance. This is used to simulate\n *                           the `bindToController` feature and simplify certain kinds of tests.\n * @return {Object} Instance of given controller.\n */\nfunction createControllerDecorator(compileProvider) {\n  angular.mock.$ControllerDecorator = ['$delegate', function($delegate) {\n    return function(expression, locals, later, ident) {\n      if (later && typeof later === 'object') {\n        var preAssignBindingsEnabled = compileProvider.preAssignBindingsEnabled();\n\n        var instantiate = $delegate(expression, locals, true, ident);\n        if (preAssignBindingsEnabled) {\n          angular.extend(instantiate.instance, later);\n        }\n\n        var instance = instantiate();\n        if (!preAssignBindingsEnabled || instance !== instantiate.instance) {\n          angular.extend(instance, later);\n        }\n\n        return instance;\n      }\n      return $delegate(expression, locals, later, ident);\n    };\n  }];\n\n  return angular.mock.$ControllerDecorator;\n}\n\n/**\n * @ngdoc service\n * @name $componentController\n * @description\n * A service that can be used to create instances of component controllers. Useful for unit-testing.\n *\n * Be aware that the controller will be instantiated and attached to the scope as specified in\n * the component definition object. If you do not provide a `$scope` object in the `locals` param\n * then the helper will create a new isolated scope as a child of `$rootScope`.\n *\n * If you are using `$element` or `$attrs` in the controller, make sure to provide them as `locals`.\n * The `$element` must be a jqLite-wrapped DOM element, and `$attrs` should be an object that\n * has all properties / functions that you are using in the controller. If this is getting too complex,\n * you should compile the component instead and access the component's controller via the\n * {@link angular.element#methods `controller`} function.\n *\n * See also the section on {@link guide/component#unit-testing-component-controllers unit-testing component controllers}\n * in the guide.\n *\n * @param {string} componentName the name of the component whose controller we want to instantiate\n * @param {Object} locals Injection locals for Controller.\n * @param {Object=} bindings Properties to add to the controller before invoking the constructor. This is used\n *                           to simulate the `bindToController` feature and simplify certain kinds of tests.\n * @param {string=} ident Override the property name to use when attaching the controller to the scope.\n * @return {Object} Instance of requested controller.\n */\nangular.mock.$ComponentControllerProvider = ['$compileProvider',\n    function ComponentControllerProvider($compileProvider) {\n  this.$get = ['$controller','$injector', '$rootScope', function($controller, $injector, $rootScope) {\n    return function $componentController(componentName, locals, bindings, ident) {\n      // get all directives associated to the component name\n      var directives = $injector.get(componentName + 'Directive');\n      // look for those directives that are components\n      var candidateDirectives = directives.filter(function(directiveInfo) {\n        // components have controller, controllerAs and restrict:'E'\n        return directiveInfo.controller && directiveInfo.controllerAs && directiveInfo.restrict === 'E';\n      });\n      // check if valid directives found\n      if (candidateDirectives.length === 0) {\n        throw new Error('No component found');\n      }\n      if (candidateDirectives.length > 1) {\n        throw new Error('Too many components found');\n      }\n      // get the info of the component\n      var directiveInfo = candidateDirectives[0];\n      // create a scope if needed\n      locals = locals || {};\n      locals.$scope = locals.$scope || $rootScope.$new(true);\n      return $controller(directiveInfo.controller, locals, bindings, ident || directiveInfo.controllerAs);\n    };\n  }];\n}];\n\n\n/**\n * @ngdoc module\n * @name ngMock\n * @packageName angular-mocks\n * @description\n *\n * # ngMock\n *\n * The `ngMock` module provides support to inject and mock Angular services into unit tests.\n * In addition, ngMock also extends various core ng services such that they can be\n * inspected and controlled in a synchronous manner within test code.\n *\n *\n * <div doc-module-components=\"ngMock\"></div>\n *\n * @installation\n *\n *  First, download the file:\n *  * [Google CDN](https://developers.google.com/speed/libraries/devguide#angularjs) e.g.\n *    `\"//ajax.googleapis.com/ajax/libs/angularjs/X.Y.Z/angular-mocks.js\"`\n *  * [NPM](https://www.npmjs.com/) e.g. `npm install angular-mocks@X.Y.Z`\n *  * [Yarn](https://yarnpkg.com) e.g. `yarn add angular-mocks@X.Y.Z`\n *  * [Bower](http://bower.io) e.g. `bower install angular-mocks#X.Y.Z`\n *  * [code.angularjs.org](https://code.angularjs.org/) (discouraged for production use)  e.g.\n *    `\"//code.angularjs.org/X.Y.Z/angular-mocks.js\"`\n *\n * where X.Y.Z is the AngularJS version you are running.\n *\n * Then, configure your test runner to load `angular-mocks.js` after `angular.js`.\n * This example uses <a href=\"http://karma-runner.github.io/\">Karma</a>:\n *\n * ```\n * config.set({\n *   files: [\n *     'build/angular.js', // and other module files you need\n *     'build/angular-mocks.js',\n *     '<path/to/application/files>',\n *     '<path/to/spec/files>'\n *   ]\n * });\n * ```\n *\n * Including the `angular-mocks.js` file automatically adds the `ngMock` module, so your tests\n *  are ready to go!\n */\nangular.module('ngMock', ['ng']).provider({\n  $browser: angular.mock.$BrowserProvider,\n  $exceptionHandler: angular.mock.$ExceptionHandlerProvider,\n  $log: angular.mock.$LogProvider,\n  $interval: angular.mock.$IntervalProvider,\n  $rootElement: angular.mock.$RootElementProvider,\n  $componentController: angular.mock.$ComponentControllerProvider\n}).config(['$provide', '$compileProvider', function($provide, $compileProvider) {\n  $provide.decorator('$timeout', angular.mock.$TimeoutDecorator);\n  $provide.decorator('$$rAF', angular.mock.$RAFDecorator);\n  $provide.decorator('$rootScope', angular.mock.$RootScopeDecorator);\n  $provide.decorator('$controller', createControllerDecorator($compileProvider));\n  $provide.decorator('$httpBackend', angular.mock.$httpBackendDecorator);\n}]).info({ angularVersion: '1.6.6' });\n\n/**\n * @ngdoc module\n * @name ngMockE2E\n * @module ngMockE2E\n * @packageName angular-mocks\n * @description\n *\n * The `ngMockE2E` is an angular module which contains mocks suitable for end-to-end testing.\n * Currently there is only one mock present in this module -\n * the {@link ngMockE2E.$httpBackend e2e $httpBackend} mock.\n */\nangular.module('ngMockE2E', ['ng']).config(['$provide', function($provide) {\n  $provide.decorator('$httpBackend', angular.mock.e2e.$httpBackendDecorator);\n}]).info({ angularVersion: '1.6.6' });\n\n/**\n * @ngdoc service\n * @name $httpBackend\n * @module ngMockE2E\n * @description\n * Fake HTTP backend implementation suitable for end-to-end testing or backend-less development of\n * applications that use the {@link ng.$http $http service}.\n *\n * <div class=\"alert alert-info\">\n * **Note**: For fake http backend implementation suitable for unit testing please see\n * {@link ngMock.$httpBackend unit-testing $httpBackend mock}.\n * </div>\n *\n * This implementation can be used to respond with static or dynamic responses via the `when` api\n * and its shortcuts (`whenGET`, `whenPOST`, etc) and optionally pass through requests to the\n * real $httpBackend for specific requests (e.g. to interact with certain remote apis or to fetch\n * templates from a webserver).\n *\n * As opposed to unit-testing, in an end-to-end testing scenario or in scenario when an application\n * is being developed with the real backend api replaced with a mock, it is often desirable for\n * certain category of requests to bypass the mock and issue a real http request (e.g. to fetch\n * templates or static files from the webserver). To configure the backend with this behavior\n * use the `passThrough` request handler of `when` instead of `respond`.\n *\n * Additionally, we don't want to manually have to flush mocked out requests like we do during unit\n * testing. For this reason the e2e $httpBackend flushes mocked out requests\n * automatically, closely simulating the behavior of the XMLHttpRequest object.\n *\n * To setup the application to run with this http backend, you have to create a module that depends\n * on the `ngMockE2E` and your application modules and defines the fake backend:\n *\n * ```js\n *   var myAppDev = angular.module('myAppDev', ['myApp', 'ngMockE2E']);\n *   myAppDev.run(function($httpBackend) {\n *     var phones = [{name: 'phone1'}, {name: 'phone2'}];\n *\n *     // returns the current list of phones\n *     $httpBackend.whenGET('/phones').respond(phones);\n *\n *     // adds a new phone to the phones array\n *     $httpBackend.whenPOST('/phones').respond(function(method, url, data) {\n *       var phone = angular.fromJson(data);\n *       phones.push(phone);\n *       return [200, phone, {}];\n *     });\n *     $httpBackend.whenGET(/^\\/templates\\//).passThrough(); // Requests for templates are handled by the real server\n *     //...\n *   });\n * ```\n *\n * Afterwards, bootstrap your app with this new module.\n *\n * ## Example\n * <example name=\"httpbackend-e2e-testing\" module=\"myAppE2E\" deps=\"angular-mocks.js\">\n * <file name=\"app.js\">\n *   var myApp = angular.module('myApp', []);\n *\n *   myApp.controller('MainCtrl', function MainCtrl($http) {\n *     var ctrl = this;\n *\n *     ctrl.phones = [];\n *     ctrl.newPhone = {\n *       name: ''\n *     };\n *\n *     ctrl.getPhones = function() {\n *       $http.get('/phones').then(function(response) {\n *         ctrl.phones = response.data;\n *       });\n *     };\n *\n *     ctrl.addPhone = function(phone) {\n *       $http.post('/phones', phone).then(function() {\n *         ctrl.newPhone = {name: ''};\n *         return ctrl.getPhones();\n *       });\n *     };\n *\n *     ctrl.getPhones();\n *   });\n * </file>\n * <file name=\"e2e.js\">\n *   var myAppDev = angular.module('myAppE2E', ['myApp', 'ngMockE2E']);\n *\n *   myAppDev.run(function($httpBackend) {\n *     var phones = [{name: 'phone1'}, {name: 'phone2'}];\n *\n *     // returns the current list of phones\n *     $httpBackend.whenGET('/phones').respond(phones);\n *\n *     // adds a new phone to the phones array\n *     $httpBackend.whenPOST('/phones').respond(function(method, url, data) {\n *       var phone = angular.fromJson(data);\n *       phones.push(phone);\n *       return [200, phone, {}];\n *     });\n *   });\n * </file>\n * <file name=\"index.html\">\n *   <div ng-controller=\"MainCtrl as $ctrl\">\n *   <form name=\"newPhoneForm\" ng-submit=\"$ctrl.addPhone($ctrl.newPhone)\">\n *     <input type=\"text\" ng-model=\"$ctrl.newPhone.name\">\n *     <input type=\"submit\" value=\"Add Phone\">\n *   </form>\n *   <h1>Phones</h1>\n *   <ul>\n *     <li ng-repeat=\"phone in $ctrl.phones\">{{phone.name}}</li>\n *   </ul>\n *   </div>\n * </file>\n * </example>\n *\n *\n */\n\n/**\n * @ngdoc method\n * @name $httpBackend#when\n * @module ngMockE2E\n * @description\n * Creates a new backend definition.\n *\n * @param {string} method HTTP method.\n * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\n *   and returns true if the url matches the current definition.\n * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives\n *   data string and returns true if the data is as expected.\n * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header\n *   object and returns true if the headers match the current definition.\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\n *   {@link ngMock.$httpBackend $httpBackend mock}.\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\n *   control how a matched request is handled. You can save this object for later use and invoke\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\n *\n *  - respond \n *    ```\n *    { function([status,] data[, headers, statusText])\n *    | function(function(method, url, data, headers, params)}\n *    ```\n *     The respond method takes a set of static data to be returned or a function that can return\n *    an array containing response status (number), response data (Array|Object|string), response\n *    headers (Object), and the text for the status (string).\n *  - passThrough  `{function()}`  Any request matching a backend definition with\n *    `passThrough` handler will be passed through to the real backend (an XHR request will be made\n *    to the server.)\n *  - Both methods return the `requestHandler` object for possible overrides.\n */\n\n/**\n * @ngdoc method\n * @name $httpBackend#whenGET\n * @module ngMockE2E\n * @description\n * Creates a new backend definition for GET requests. For more info see `when()`.\n *\n * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\n *   and returns true if the url matches the current definition.\n * @param {(Object|function(Object))=} headers HTTP headers.\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\n *   {@link ngMock.$httpBackend $httpBackend mock}.\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\n *   control how a matched request is handled. You can save this object for later use and invoke\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\n */\n\n/**\n * @ngdoc method\n * @name $httpBackend#whenHEAD\n * @module ngMockE2E\n * @description\n * Creates a new backend definition for HEAD requests. For more info see `when()`.\n *\n * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\n *   and returns true if the url matches the current definition.\n * @param {(Object|function(Object))=} headers HTTP headers.\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\n *   {@link ngMock.$httpBackend $httpBackend mock}.\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\n *   control how a matched request is handled. You can save this object for later use and invoke\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\n */\n\n/**\n * @ngdoc method\n * @name $httpBackend#whenDELETE\n * @module ngMockE2E\n * @description\n * Creates a new backend definition for DELETE requests. For more info see `when()`.\n *\n * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\n *   and returns true if the url matches the current definition.\n * @param {(Object|function(Object))=} headers HTTP headers.\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\n *   {@link ngMock.$httpBackend $httpBackend mock}.\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\n *   control how a matched request is handled. You can save this object for later use and invoke\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\n */\n\n/**\n * @ngdoc method\n * @name $httpBackend#whenPOST\n * @module ngMockE2E\n * @description\n * Creates a new backend definition for POST requests. For more info see `when()`.\n *\n * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\n *   and returns true if the url matches the current definition.\n * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives\n *   data string and returns true if the data is as expected.\n * @param {(Object|function(Object))=} headers HTTP headers.\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\n *   {@link ngMock.$httpBackend $httpBackend mock}.\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\n *   control how a matched request is handled. You can save this object for later use and invoke\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\n */\n\n/**\n * @ngdoc method\n * @name $httpBackend#whenPUT\n * @module ngMockE2E\n * @description\n * Creates a new backend definition for PUT requests.  For more info see `when()`.\n *\n * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\n *   and returns true if the url matches the current definition.\n * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives\n *   data string and returns true if the data is as expected.\n * @param {(Object|function(Object))=} headers HTTP headers.\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\n *   {@link ngMock.$httpBackend $httpBackend mock}.\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\n *   control how a matched request is handled. You can save this object for later use and invoke\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\n */\n\n/**\n * @ngdoc method\n * @name $httpBackend#whenPATCH\n * @module ngMockE2E\n * @description\n * Creates a new backend definition for PATCH requests.  For more info see `when()`.\n *\n * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\n *   and returns true if the url matches the current definition.\n * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives\n *   data string and returns true if the data is as expected.\n * @param {(Object|function(Object))=} headers HTTP headers.\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\n *   {@link ngMock.$httpBackend $httpBackend mock}.\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\n *   control how a matched request is handled. You can save this object for later use and invoke\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\n */\n\n/**\n * @ngdoc method\n * @name $httpBackend#whenJSONP\n * @module ngMockE2E\n * @description\n * Creates a new backend definition for JSONP requests. For more info see `when()`.\n *\n * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\n *   and returns true if the url matches the current definition.\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\n *   {@link ngMock.$httpBackend $httpBackend mock}.\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\n *   control how a matched request is handled. You can save this object for later use and invoke\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\n */\n/**\n * @ngdoc method\n * @name $httpBackend#whenRoute\n * @module ngMockE2E\n * @description\n * Creates a new backend definition that compares only with the requested route.\n *\n * @param {string} method HTTP method.\n * @param {string} url HTTP url string that supports colon param matching.\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\n *   control how a matched request is handled. You can save this object for later use and invoke\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\n */\nangular.mock.e2e = {};\nangular.mock.e2e.$httpBackendDecorator =\n  ['$rootScope', '$timeout', '$delegate', '$browser', createHttpBackendMock];\n\n\n/**\n * @ngdoc type\n * @name $rootScope.Scope\n * @module ngMock\n * @description\n * {@link ng.$rootScope.Scope Scope} type decorated with helper methods useful for testing. These\n * methods are automatically available on any {@link ng.$rootScope.Scope Scope} instance when\n * `ngMock` module is loaded.\n *\n * In addition to all the regular `Scope` methods, the following helper methods are available:\n */\nangular.mock.$RootScopeDecorator = ['$delegate', function($delegate) {\n\n  var $rootScopePrototype = Object.getPrototypeOf($delegate);\n\n  $rootScopePrototype.$countChildScopes = countChildScopes;\n  $rootScopePrototype.$countWatchers = countWatchers;\n\n  return $delegate;\n\n  // ------------------------------------------------------------------------------------------ //\n\n  /**\n   * @ngdoc method\n   * @name $rootScope.Scope#$countChildScopes\n   * @module ngMock\n   * @this $rootScope.Scope\n   * @description\n   * Counts all the direct and indirect child scopes of the current scope.\n   *\n   * The current scope is excluded from the count. The count includes all isolate child scopes.\n   *\n   * @returns {number} Total number of child scopes.\n   */\n  function countChildScopes() {\n    var count = 0; // exclude the current scope\n    var pendingChildHeads = [this.$$childHead];\n    var currentScope;\n\n    while (pendingChildHeads.length) {\n      currentScope = pendingChildHeads.shift();\n\n      while (currentScope) {\n        count += 1;\n        pendingChildHeads.push(currentScope.$$childHead);\n        currentScope = currentScope.$$nextSibling;\n      }\n    }\n\n    return count;\n  }\n\n\n  /**\n   * @ngdoc method\n   * @name $rootScope.Scope#$countWatchers\n   * @this $rootScope.Scope\n   * @module ngMock\n   * @description\n   * Counts all the watchers of direct and indirect child scopes of the current scope.\n   *\n   * The watchers of the current scope are included in the count and so are all the watchers of\n   * isolate child scopes.\n   *\n   * @returns {number} Total number of watchers.\n   */\n  function countWatchers() {\n    var count = this.$$watchers ? this.$$watchers.length : 0; // include the current scope\n    var pendingChildHeads = [this.$$childHead];\n    var currentScope;\n\n    while (pendingChildHeads.length) {\n      currentScope = pendingChildHeads.shift();\n\n      while (currentScope) {\n        count += currentScope.$$watchers ? currentScope.$$watchers.length : 0;\n        pendingChildHeads.push(currentScope.$$childHead);\n        currentScope = currentScope.$$nextSibling;\n      }\n    }\n\n    return count;\n  }\n}];\n\n\n(function(jasmineOrMocha) {\n\n  if (!jasmineOrMocha) {\n    return;\n  }\n\n  var currentSpec = null,\n      injectorState = new InjectorState(),\n      annotatedFunctions = [],\n      wasInjectorCreated = function() {\n        return !!currentSpec;\n      };\n\n  angular.mock.$$annotate = angular.injector.$$annotate;\n  angular.injector.$$annotate = function(fn) {\n    if (typeof fn === 'function' && !fn.$inject) {\n      annotatedFunctions.push(fn);\n    }\n    return angular.mock.$$annotate.apply(this, arguments);\n  };\n\n  /**\n   * @ngdoc function\n   * @name angular.mock.module\n   * @description\n   *\n   * *NOTE*: This function is also published on window for easy access.<br>\n   * *NOTE*: This function is declared ONLY WHEN running tests with jasmine or mocha\n   *\n   * This function registers a module configuration code. It collects the configuration information\n   * which will be used when the injector is created by {@link angular.mock.inject inject}.\n   *\n   * See {@link angular.mock.inject inject} for usage example\n   *\n   * @param {...(string|Function|Object)} fns any number of modules which are represented as string\n   *        aliases or as anonymous module initialization functions. The modules are used to\n   *        configure the injector. The 'ng' and 'ngMock' modules are automatically loaded. If an\n   *        object literal is passed each key-value pair will be registered on the module via\n   *        {@link auto.$provide $provide}.value, the key being the string name (or token) to associate\n   *        with the value on the injector.\n   */\n  var module = window.module = angular.mock.module = function() {\n    var moduleFns = Array.prototype.slice.call(arguments, 0);\n    return wasInjectorCreated() ? workFn() : workFn;\n    /////////////////////\n    function workFn() {\n      if (currentSpec.$injector) {\n        throw new Error('Injector already created, can not register a module!');\n      } else {\n        var fn, modules = currentSpec.$modules || (currentSpec.$modules = []);\n        angular.forEach(moduleFns, function(module) {\n          if (angular.isObject(module) && !angular.isArray(module)) {\n            fn = ['$provide', function($provide) {\n              angular.forEach(module, function(value, key) {\n                $provide.value(key, value);\n              });\n            }];\n          } else {\n            fn = module;\n          }\n          if (currentSpec.$providerInjector) {\n            currentSpec.$providerInjector.invoke(fn);\n          } else {\n            modules.push(fn);\n          }\n        });\n      }\n    }\n  };\n\n  module.$$beforeAllHook = (window.before || window.beforeAll);\n  module.$$afterAllHook = (window.after || window.afterAll);\n\n  // purely for testing ngMock itself\n  module.$$currentSpec = function(to) {\n    if (arguments.length === 0) return to;\n    currentSpec = to;\n  };\n\n  /**\n   * @ngdoc function\n   * @name angular.mock.module.sharedInjector\n   * @description\n   *\n   * *NOTE*: This function is declared ONLY WHEN running tests with jasmine or mocha\n   *\n   * This function ensures a single injector will be used for all tests in a given describe context.\n   * This contrasts with the default behaviour where a new injector is created per test case.\n   *\n   * Use sharedInjector when you want to take advantage of Jasmine's `beforeAll()`, or mocha's\n   * `before()` methods. Call `module.sharedInjector()` before you setup any other hooks that\n   * will create (i.e call `module()`) or use (i.e call `inject()`) the injector.\n   *\n   * You cannot call `sharedInjector()` from within a context already using `sharedInjector()`.\n   *\n   * ## Example\n   *\n   * Typically beforeAll is used to make many assertions about a single operation. This can\n   * cut down test run-time as the test setup doesn't need to be re-run, and enabling focussed\n   * tests each with a single assertion.\n   *\n   * ```js\n   * describe(\"Deep Thought\", function() {\n   *\n   *   module.sharedInjector();\n   *\n   *   beforeAll(module(\"UltimateQuestion\"));\n   *\n   *   beforeAll(inject(function(DeepThought) {\n   *     expect(DeepThought.answer).toBeUndefined();\n   *     DeepThought.generateAnswer();\n   *   }));\n   *\n   *   it(\"has calculated the answer correctly\", inject(function(DeepThought) {\n   *     // Because of sharedInjector, we have access to the instance of the DeepThought service\n   *     // that was provided to the beforeAll() hook. Therefore we can test the generated answer\n   *     expect(DeepThought.answer).toBe(42);\n   *   }));\n   *\n   *   it(\"has calculated the answer within the expected time\", inject(function(DeepThought) {\n   *     expect(DeepThought.runTimeMillennia).toBeLessThan(8000);\n   *   }));\n   *\n   *   it(\"has double checked the answer\", inject(function(DeepThought) {\n   *     expect(DeepThought.absolutelySureItIsTheRightAnswer).toBe(true);\n   *   }));\n   *\n   * });\n   *\n   * ```\n   */\n  module.sharedInjector = function() {\n    if (!(module.$$beforeAllHook && module.$$afterAllHook)) {\n      throw Error('sharedInjector() cannot be used unless your test runner defines beforeAll/afterAll');\n    }\n\n    var initialized = false;\n\n    module.$$beforeAllHook(/** @this */ function() {\n      if (injectorState.shared) {\n        injectorState.sharedError = Error('sharedInjector() cannot be called inside a context that has already called sharedInjector()');\n        throw injectorState.sharedError;\n      }\n      initialized = true;\n      currentSpec = this;\n      injectorState.shared = true;\n    });\n\n    module.$$afterAllHook(function() {\n      if (initialized) {\n        injectorState = new InjectorState();\n        module.$$cleanup();\n      } else {\n        injectorState.sharedError = null;\n      }\n    });\n  };\n\n  module.$$beforeEach = function() {\n    if (injectorState.shared && currentSpec && currentSpec !== this) {\n      var state = currentSpec;\n      currentSpec = this;\n      angular.forEach(['$injector','$modules','$providerInjector', '$injectorStrict'], function(k) {\n        currentSpec[k] = state[k];\n        state[k] = null;\n      });\n    } else {\n      currentSpec = this;\n      originalRootElement = null;\n      annotatedFunctions = [];\n    }\n  };\n\n  module.$$afterEach = function() {\n    if (injectorState.cleanupAfterEach()) {\n      module.$$cleanup();\n    }\n  };\n\n  module.$$cleanup = function() {\n    var injector = currentSpec.$injector;\n\n    annotatedFunctions.forEach(function(fn) {\n      delete fn.$inject;\n    });\n\n    currentSpec.$injector = null;\n    currentSpec.$modules = null;\n    currentSpec.$providerInjector = null;\n    currentSpec = null;\n\n    if (injector) {\n      // Ensure `$rootElement` is instantiated, before checking `originalRootElement`\n      var $rootElement = injector.get('$rootElement');\n      var rootNode = $rootElement && $rootElement[0];\n      var cleanUpNodes = !originalRootElement ? [] : [originalRootElement[0]];\n      if (rootNode && (!originalRootElement || rootNode !== originalRootElement[0])) {\n        cleanUpNodes.push(rootNode);\n      }\n      angular.element.cleanData(cleanUpNodes);\n\n      // Ensure `$destroy()` is available, before calling it\n      // (a mocked `$rootScope` might not implement it (or not even be an object at all))\n      var $rootScope = injector.get('$rootScope');\n      if ($rootScope && $rootScope.$destroy) $rootScope.$destroy();\n    }\n\n    // clean up jquery's fragment cache\n    angular.forEach(angular.element.fragments, function(val, key) {\n      delete angular.element.fragments[key];\n    });\n\n    MockXhr.$$lastInstance = null;\n\n    angular.forEach(angular.callbacks, function(val, key) {\n      delete angular.callbacks[key];\n    });\n    angular.callbacks.$$counter = 0;\n  };\n\n  (window.beforeEach || window.setup)(module.$$beforeEach);\n  (window.afterEach || window.teardown)(module.$$afterEach);\n\n  /**\n   * @ngdoc function\n   * @name angular.mock.inject\n   * @description\n   *\n   * *NOTE*: This function is also published on window for easy access.<br>\n   * *NOTE*: This function is declared ONLY WHEN running tests with jasmine or mocha\n   *\n   * The inject function wraps a function into an injectable function. The inject() creates new\n   * instance of {@link auto.$injector $injector} per test, which is then used for\n   * resolving references.\n   *\n   *\n   * ## Resolving References (Underscore Wrapping)\n   * Often, we would like to inject a reference once, in a `beforeEach()` block and reuse this\n   * in multiple `it()` clauses. To be able to do this we must assign the reference to a variable\n   * that is declared in the scope of the `describe()` block. Since we would, most likely, want\n   * the variable to have the same name of the reference we have a problem, since the parameter\n   * to the `inject()` function would hide the outer variable.\n   *\n   * To help with this, the injected parameters can, optionally, be enclosed with underscores.\n   * These are ignored by the injector when the reference name is resolved.\n   *\n   * For example, the parameter `_myService_` would be resolved as the reference `myService`.\n   * Since it is available in the function body as `_myService_`, we can then assign it to a variable\n   * defined in an outer scope.\n   *\n   * ```\n   * // Defined out reference variable outside\n   * var myService;\n   *\n   * // Wrap the parameter in underscores\n   * beforeEach( inject( function(_myService_){\n   *   myService = _myService_;\n   * }));\n   *\n   * // Use myService in a series of tests.\n   * it('makes use of myService', function() {\n   *   myService.doStuff();\n   * });\n   *\n   * ```\n   *\n   * See also {@link angular.mock.module angular.mock.module}\n   *\n   * ## Example\n   * Example of what a typical jasmine tests looks like with the inject method.\n   * ```js\n   *\n   *   angular.module('myApplicationModule', [])\n   *       .value('mode', 'app')\n   *       .value('version', 'v1.0.1');\n   *\n   *\n   *   describe('MyApp', function() {\n   *\n   *     // You need to load modules that you want to test,\n   *     // it loads only the \"ng\" module by default.\n   *     beforeEach(module('myApplicationModule'));\n   *\n   *\n   *     // inject() is used to inject arguments of all given functions\n   *     it('should provide a version', inject(function(mode, version) {\n   *       expect(version).toEqual('v1.0.1');\n   *       expect(mode).toEqual('app');\n   *     }));\n   *\n   *\n   *     // The inject and module method can also be used inside of the it or beforeEach\n   *     it('should override a version and test the new version is injected', function() {\n   *       // module() takes functions or strings (module aliases)\n   *       module(function($provide) {\n   *         $provide.value('version', 'overridden'); // override version here\n   *       });\n   *\n   *       inject(function(version) {\n   *         expect(version).toEqual('overridden');\n   *       });\n   *     });\n   *   });\n   *\n   * ```\n   *\n   * @param {...Function} fns any number of functions which will be injected using the injector.\n   */\n\n\n\n  var ErrorAddingDeclarationLocationStack = function ErrorAddingDeclarationLocationStack(e, errorForStack) {\n    this.message = e.message;\n    this.name = e.name;\n    if (e.line) this.line = e.line;\n    if (e.sourceId) this.sourceId = e.sourceId;\n    if (e.stack && errorForStack)\n      this.stack = e.stack + '\\n' + errorForStack.stack;\n    if (e.stackArray) this.stackArray = e.stackArray;\n  };\n  ErrorAddingDeclarationLocationStack.prototype = Error.prototype;\n\n  window.inject = angular.mock.inject = function() {\n    var blockFns = Array.prototype.slice.call(arguments, 0);\n    var errorForStack = new Error('Declaration Location');\n    // IE10+ and PhanthomJS do not set stack trace information, until the error is thrown\n    if (!errorForStack.stack) {\n      try {\n        throw errorForStack;\n      } catch (e) { /* empty */ }\n    }\n    return wasInjectorCreated() ? WorkFn.call(currentSpec) : WorkFn;\n    /////////////////////\n    function WorkFn() {\n      var modules = currentSpec.$modules || [];\n      var strictDi = !!currentSpec.$injectorStrict;\n      modules.unshift(['$injector', function($injector) {\n        currentSpec.$providerInjector = $injector;\n      }]);\n      modules.unshift('ngMock');\n      modules.unshift('ng');\n      var injector = currentSpec.$injector;\n      if (!injector) {\n        if (strictDi) {\n          // If strictDi is enabled, annotate the providerInjector blocks\n          angular.forEach(modules, function(moduleFn) {\n            if (typeof moduleFn === 'function') {\n              angular.injector.$$annotate(moduleFn);\n            }\n          });\n        }\n        injector = currentSpec.$injector = angular.injector(modules, strictDi);\n        currentSpec.$injectorStrict = strictDi;\n      }\n      for (var i = 0, ii = blockFns.length; i < ii; i++) {\n        if (currentSpec.$injectorStrict) {\n          // If the injector is strict / strictDi, and the spec wants to inject using automatic\n          // annotation, then annotate the function here.\n          injector.annotate(blockFns[i]);\n        }\n        try {\n          injector.invoke(blockFns[i] || angular.noop, this);\n        } catch (e) {\n          if (e.stack && errorForStack) {\n            throw new ErrorAddingDeclarationLocationStack(e, errorForStack);\n          }\n          throw e;\n        } finally {\n          errorForStack = null;\n        }\n      }\n    }\n  };\n\n\n  angular.mock.inject.strictDi = function(value) {\n    value = arguments.length ? !!value : true;\n    return wasInjectorCreated() ? workFn() : workFn;\n\n    function workFn() {\n      if (value !== currentSpec.$injectorStrict) {\n        if (currentSpec.$injector) {\n          throw new Error('Injector already created, can not modify strict annotations');\n        } else {\n          currentSpec.$injectorStrict = value;\n        }\n      }\n    }\n  };\n\n  function InjectorState() {\n    this.shared = false;\n    this.sharedError = null;\n\n    this.cleanupAfterEach = function() {\n      return !this.shared || this.sharedError;\n    };\n  }\n})(window.jasmine || window.mocha);\n\n'use strict';\n\n(function() {\n  /**\n   * Triggers a browser event. Attempts to choose the right event if one is\n   * not specified.\n   *\n   * @param {Object} element Either a wrapped jQuery/jqLite node or a DOMElement\n   * @param {string} eventType Optional event type\n   * @param {Object=} eventData An optional object which contains additional event data (such as x,y\n   * coordinates, keys, etc...) that are passed into the event when triggered\n   */\n  window.browserTrigger = function browserTrigger(element, eventType, eventData) {\n    if (element && !element.nodeName) element = element[0];\n    if (!element) return;\n\n    eventData = eventData || {};\n    var relatedTarget = eventData.relatedTarget || element;\n    var keys = eventData.keys;\n    var x = eventData.x;\n    var y = eventData.y;\n\n    var inputType = (element.type) ? element.type.toLowerCase() : null,\n        nodeName = element.nodeName.toLowerCase();\n    if (!eventType) {\n      eventType = {\n        'text':            'change',\n        'textarea':        'change',\n        'hidden':          'change',\n        'password':        'change',\n        'button':          'click',\n        'submit':          'click',\n        'reset':           'click',\n        'image':           'click',\n        'checkbox':        'click',\n        'radio':           'click',\n        'select-one':      'change',\n        'select-multiple': 'change',\n        '_default_':       'click'\n      }[inputType || '_default_'];\n    }\n\n    if (nodeName === 'option') {\n      element.parentNode.value = element.value;\n      element = element.parentNode;\n      eventType = 'change';\n    }\n\n    keys = keys || [];\n    function pressed(key) {\n      return keys.indexOf(key) !== -1;\n    }\n\n    var evnt;\n    if (/transitionend/.test(eventType)) {\n      if (window.WebKitTransitionEvent) {\n        evnt = new window.WebKitTransitionEvent(eventType, eventData);\n        evnt.initEvent(eventType, false, true);\n      } else {\n        try {\n          evnt = new window.TransitionEvent(eventType, eventData);\n        } catch (e) {\n          evnt = window.document.createEvent('TransitionEvent');\n          evnt.initTransitionEvent(eventType, null, null, null, eventData.elapsedTime || 0);\n        }\n      }\n    } else if (/animationend/.test(eventType)) {\n      if (window.WebKitAnimationEvent) {\n        evnt = new window.WebKitAnimationEvent(eventType, eventData);\n        evnt.initEvent(eventType, false, true);\n      } else {\n        try {\n          evnt = new window.AnimationEvent(eventType, eventData);\n        } catch (e) {\n          evnt = window.document.createEvent('AnimationEvent');\n          evnt.initAnimationEvent(eventType, null, null, null, eventData.elapsedTime || 0);\n        }\n      }\n    } else if (/touch/.test(eventType) && supportsTouchEvents()) {\n      evnt = createTouchEvent(element, eventType, x, y);\n    } else if (/key/.test(eventType)) {\n      evnt = window.document.createEvent('Events');\n      evnt.initEvent(eventType, eventData.bubbles, eventData.cancelable);\n      evnt.view = window;\n      evnt.ctrlKey = pressed('ctrl');\n      evnt.altKey = pressed('alt');\n      evnt.shiftKey = pressed('shift');\n      evnt.metaKey = pressed('meta');\n      evnt.keyCode = eventData.keyCode;\n      evnt.charCode = eventData.charCode;\n      evnt.which = eventData.which;\n    } else {\n      evnt = window.document.createEvent('MouseEvents');\n      x = x || 0;\n      y = y || 0;\n      evnt.initMouseEvent(eventType, true, true, window, 0, x, y, x, y, pressed('ctrl'),\n          pressed('alt'), pressed('shift'), pressed('meta'), 0, relatedTarget);\n    }\n\n    /* we're unable to change the timeStamp value directly so this\n     * is only here to allow for testing where the timeStamp value is\n     * read */\n    evnt.$manualTimeStamp = eventData.timeStamp;\n\n    if (!evnt) return;\n\n    var originalPreventDefault = evnt.preventDefault,\n        appWindow = element.ownerDocument.defaultView,\n        fakeProcessDefault = true,\n        finalProcessDefault,\n        angular = appWindow.angular || {};\n\n    // igor: temporary fix for https://bugzilla.mozilla.org/show_bug.cgi?id=684208\n    angular['ff-684208-preventDefault'] = false;\n    evnt.preventDefault = function() {\n      fakeProcessDefault = false;\n      return originalPreventDefault.apply(evnt, arguments);\n    };\n\n    if (!eventData.bubbles || supportsEventBubblingInDetachedTree() || isAttachedToDocument(element)) {\n      element.dispatchEvent(evnt);\n    } else {\n      triggerForPath(element, evnt);\n    }\n\n    finalProcessDefault = !(angular['ff-684208-preventDefault'] || !fakeProcessDefault);\n\n    delete angular['ff-684208-preventDefault'];\n\n    return finalProcessDefault;\n  };\n\n  function supportsTouchEvents() {\n    if ('_cached' in supportsTouchEvents) {\n      return supportsTouchEvents._cached;\n    }\n    if (!window.document.createTouch || !window.document.createTouchList) {\n      supportsTouchEvents._cached = false;\n      return false;\n    }\n    try {\n      window.document.createEvent('TouchEvent');\n    } catch (e) {\n      supportsTouchEvents._cached = false;\n      return false;\n    }\n    supportsTouchEvents._cached = true;\n    return true;\n  }\n\n  function createTouchEvent(element, eventType, x, y) {\n    var evnt = new window.Event(eventType);\n    x = x || 0;\n    y = y || 0;\n\n    var touch = window.document.createTouch(window, element, Date.now(), x, y, x, y);\n    var touches = window.document.createTouchList(touch);\n\n    evnt.touches = touches;\n\n    return evnt;\n  }\n\n  function supportsEventBubblingInDetachedTree() {\n    if ('_cached' in supportsEventBubblingInDetachedTree) {\n      return supportsEventBubblingInDetachedTree._cached;\n    }\n    supportsEventBubblingInDetachedTree._cached = false;\n    var doc = window.document;\n    if (doc) {\n      var parent = doc.createElement('div'),\n          child = parent.cloneNode();\n      parent.appendChild(child);\n      parent.addEventListener('e', function() {\n        supportsEventBubblingInDetachedTree._cached = true;\n      });\n      var evnt = window.document.createEvent('Events');\n      evnt.initEvent('e', true, true);\n      child.dispatchEvent(evnt);\n    }\n    return supportsEventBubblingInDetachedTree._cached;\n  }\n\n  function triggerForPath(element, evnt) {\n    var stop = false;\n\n    var _stopPropagation = evnt.stopPropagation;\n    evnt.stopPropagation = function() {\n      stop = true;\n      _stopPropagation.apply(evnt, arguments);\n    };\n    patchEventTargetForBubbling(evnt, element);\n    do {\n      element.dispatchEvent(evnt);\n      // eslint-disable-next-line no-unmodified-loop-condition\n    } while (!stop && (element = element.parentNode));\n  }\n\n  function patchEventTargetForBubbling(event, target) {\n    event._target = target;\n    Object.defineProperty(event, 'target', {get: function() { return this._target;}});\n  }\n\n  function isAttachedToDocument(element) {\n    while ((element = element.parentNode)) {\n        if (element === window) {\n            return true;\n        }\n    }\n    return false;\n  }\n})();\n\n\n})(window, window.angular);\n"]}