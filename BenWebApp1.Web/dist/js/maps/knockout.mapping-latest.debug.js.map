{"version":3,"sources":["knockout.mapping-latest.debug.js"],"names":["factory","require","exports","module","define","ko","mapping","unionArrays","x","y","obj","i","length","res","k","push","extendObject","destination","source","destType","key","hasOwnProperty","getType","bothArrays","merge","obj1","obj2","merged","fillOptions","rawOptions","otherOptions","options","recognizedRootProperties","property","Object","ignore","mergeArrays","include","copy","observe","defaultOptions","mappedProperties","copiedProperties","a","b","utils","arrayGetDistinctValues","concat","withProxyDependentObservable","dependentObservables","callback","localDO","dependentObservable","read","owner","realDeferEvaluation","deferEvaluation","isRemoved","wrap","DO","tmp","realKoDependentObservable","isWriteable","isWriteableObservable","wrapped","arrayRemoveItem","apply","arguments","write","val","DEBUG","_wrapper","realDependentObservable","fn","computed","result","updateViewModel","mappedRootObject","rootObject","parentName","parent","parentPropertyName","mappedParent","isArray","unwrapObservable","isMapped","previousMapping","mappingProperty","callbackParams","data","hasCreateCallback","create","Function","createCallback","Array","skip","emptyReturn","hasUpdateCallback","update","updateCallback","params","target","observable","alreadyMapped","visitedObjects","get","changes","hasKeyCallback","keyCallback","isObservable","observableArray","mappedRemove","valueOrPredicate","predicate","value","remove","item","mappedRemoveAll","arrayOfValues","arrayOfKeys","filterArrayByKey","arrayIndexOf","mappedDestroy","destroy","mappedDestroyAll","mappedIndexOf","keys","mappedCreate","Error","newValue","currentArrayKeys","sort","newArrayKeys","j","editScript","compareArrays","ignoreIndexOf","unwrappedRootObject","itemsByKey","optimizedKeys","undefined","newContents","passedOver","mappedItem","fullPropertyName","status","getItemByKey","index","ignorableIndexOf","event","arrayChanged","arrayForEach","change","canHaveProperties","save","visitPropertiesOrArrayEntries","indexer","prevMappedProperty","retval","valueToWrite","hasCreateOrUpdateCallback","array","ignoreIndices","mapKey","arrayMap","visitorCallback","propertyName","object","type","getPropertyName","simpleObjectLookup","values","this","existingIndex","objectLookup","buckets","findBucket","bucketKey","e","bucket","mappingNesting","_defaultOptions","viewModel","unwrapped","fromJS","jsObject","pop","fromJSON","jsonString","parsed","parseJson","updateFromJS","updateFromJSON","toJS","resetDefaultOptions","visitModel","toJSON","plainJavaScriptObject","stringifyJson","slice","constructor","Date","propertyValue","previouslyMappedValue"],"mappings":"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","file":"../knockout.mapping-latest.debug.js","sourcesContent":["/// Knockout Mapping plugin v2.4.0\n/// (c) 2013 Steven Sanderson, Roy Jacobs - http://knockoutjs.com/\n/// License: MIT (http://www.opensource.org/licenses/mit-license.php)\n(function (factory) {\r\n\t// Module systems magic dance.\r\n\r\n\tif (typeof require === \"function\" && typeof exports === \"object\" && typeof module === \"object\") {\r\n\t\t// CommonJS or Node: hard-coded dependency on \"knockout\"\r\n\t\tfactory(require(\"knockout\"), exports);\r\n\t} else if (typeof define === \"function\" && define[\"amd\"]) {\r\n\t\t// AMD anonymous module with hard-coded dependency on \"knockout\"\r\n\t\tdefine([\"knockout\", \"exports\"], factory);\r\n\t} else {\r\n\t\t// <script> tag: use the global `ko` object, attaching a `mapping` property\r\n\t\tfactory(ko, ko.mapping = {});\r\n\t}\r\n}(function (ko, exports) {\r\n\tvar DEBUG=true;\r\n\tvar mappingProperty = \"__ko_mapping__\";\r\n\tvar realKoDependentObservable = ko.dependentObservable;\r\n\tvar mappingNesting = 0;\r\n\tvar dependentObservables;\r\n\tvar visitedObjects;\r\n\tvar recognizedRootProperties = [\"create\", \"update\", \"key\", \"arrayChanged\"];\r\n\tvar emptyReturn = {};\r\n\r\n\tvar _defaultOptions = {\r\n\t\tinclude: [\"_destroy\"],\r\n\t\tignore: [],\r\n\t\tcopy: [],\r\n\t\tobserve: []\r\n\t};\r\n\tvar defaultOptions = _defaultOptions;\r\n\r\n\t// Author: KennyTM @ StackOverflow\r\n\tfunction unionArrays (x, y) {\r\n\t\tvar obj = {};\r\n\t\tfor (var i = x.length - 1; i >= 0; -- i) obj[x[i]] = x[i];\r\n\t\tfor (var i = y.length - 1; i >= 0; -- i) obj[y[i]] = y[i];\r\n\t\tvar res = [];\r\n\r\n\t\tfor (var k in obj) {\r\n\t\t\tres.push(obj[k]);\r\n\t\t};\r\n\r\n\t\treturn res;\r\n\t}\r\n\r\n\tfunction extendObject(destination, source) {\r\n\t\tvar destType;\r\n\r\n\t\tfor (var key in source) {\r\n\t\t\tif (source.hasOwnProperty(key) && source[key]) {\r\n\t\t\t\tdestType = exports.getType(destination[key]);\r\n\t\t\t\tif (key && destination[key] && destType !== \"array\" && destType !== \"string\") {\r\n\t\t\t\t\textendObject(destination[key], source[key]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar bothArrays = exports.getType(destination[key]) === \"array\" && exports.getType(source[key]) === \"array\";\r\n\t\t\t\t\tif (bothArrays) {\r\n\t\t\t\t\t\tdestination[key] = unionArrays(destination[key], source[key]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tdestination[key] = source[key];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction merge(obj1, obj2) {\r\n\t\tvar merged = {};\r\n\t\textendObject(merged, obj1);\r\n\t\textendObject(merged, obj2);\r\n\r\n\t\treturn merged;\r\n\t}\r\n\r\n\texports.isMapped = function (viewModel) {\r\n\t\tvar unwrapped = ko.utils.unwrapObservable(viewModel);\r\n\t\treturn unwrapped && unwrapped[mappingProperty];\r\n\t}\r\n\r\n\texports.fromJS = function (jsObject /*, inputOptions, target*/ ) {\r\n\t\tif (arguments.length == 0) throw new Error(\"When calling ko.fromJS, pass the object you want to convert.\");\r\n\r\n\t\ttry {\r\n\t\t\tif (!mappingNesting++) {\r\n\t\t\t\tdependentObservables = [];\r\n\t\t\t\tvisitedObjects = new objectLookup();\r\n\t\t\t}\r\n\r\n\t\t\tvar options;\r\n\t\t\tvar target;\r\n\r\n\t\t\tif (arguments.length == 2) {\r\n\t\t\t\tif (arguments[1][mappingProperty]) {\r\n\t\t\t\t\ttarget = arguments[1];\r\n\t\t\t\t} else {\r\n\t\t\t\t\toptions = arguments[1];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (arguments.length == 3) {\r\n\t\t\t\toptions = arguments[1];\r\n\t\t\t\ttarget = arguments[2];\r\n\t\t\t}\r\n\r\n\t\t\tif (target) {\r\n\t\t\t\toptions = merge(options, target[mappingProperty]);\r\n\t\t\t}\r\n\t\t\toptions = fillOptions(options);\r\n\r\n\t\t\tvar result = updateViewModel(target, jsObject, options);\r\n\t\t\tif (target) {\r\n\t\t\t\tresult = target;\r\n\t\t\t}\r\n\r\n\t\t\t// Evaluate any dependent observables that were proxied.\r\n\t\t\t// Do this after the model's observables have been created\r\n\t\t\tif (!--mappingNesting) {\r\n\t\t\t\twhile (dependentObservables.length) {\r\n\t\t\t\t\tvar DO = dependentObservables.pop();\r\n\t\t\t\t\tif (DO) DO();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Save any new mapping options in the view model, so that updateFromJS can use them later.\r\n\t\t\tresult[mappingProperty] = merge(result[mappingProperty], options);\r\n\r\n\t\t\treturn result;\r\n\t\t} catch(e) {\r\n\t\t\tmappingNesting = 0;\r\n\t\t\tthrow e;\r\n\t\t}\r\n\t};\r\n\r\n\texports.fromJSON = function (jsonString /*, options, target*/ ) {\r\n\t\tvar parsed = ko.utils.parseJson(jsonString);\r\n\t\targuments[0] = parsed;\r\n\t\treturn exports.fromJS.apply(this, arguments);\r\n\t};\r\n\r\n\texports.updateFromJS = function (viewModel) {\r\n\t\tthrow new Error(\"ko.mapping.updateFromJS, use ko.mapping.fromJS instead. Please note that the order of parameters is different!\");\r\n\t};\r\n\r\n\texports.updateFromJSON = function (viewModel) {\r\n\t\tthrow new Error(\"ko.mapping.updateFromJSON, use ko.mapping.fromJSON instead. Please note that the order of parameters is different!\");\r\n\t};\r\n\r\n\texports.toJS = function (rootObject, options) {\r\n\t\tif (!defaultOptions) exports.resetDefaultOptions();\r\n\r\n\t\tif (arguments.length == 0) throw new Error(\"When calling ko.mapping.toJS, pass the object you want to convert.\");\r\n\t\tif (exports.getType(defaultOptions.ignore) !== \"array\") throw new Error(\"ko.mapping.defaultOptions().ignore should be an array.\");\r\n\t\tif (exports.getType(defaultOptions.include) !== \"array\") throw new Error(\"ko.mapping.defaultOptions().include should be an array.\");\r\n\t\tif (exports.getType(defaultOptions.copy) !== \"array\") throw new Error(\"ko.mapping.defaultOptions().copy should be an array.\");\r\n\r\n\t\t// Merge in the options used in fromJS\r\n\t\toptions = fillOptions(options, rootObject[mappingProperty]);\r\n\r\n\t\t// We just unwrap everything at every level in the object graph\r\n\t\treturn exports.visitModel(rootObject, function (x) {\r\n\t\t\treturn ko.utils.unwrapObservable(x)\r\n\t\t}, options);\r\n\t};\r\n\r\n\texports.toJSON = function (rootObject, options) {\r\n\t\tvar plainJavaScriptObject = exports.toJS(rootObject, options);\r\n\t\treturn ko.utils.stringifyJson(plainJavaScriptObject);\r\n\t};\r\n\r\n\texports.defaultOptions = function () {\r\n\t\tif (arguments.length > 0) {\r\n\t\t\tdefaultOptions = arguments[0];\r\n\t\t} else {\r\n\t\t\treturn defaultOptions;\r\n\t\t}\r\n\t};\r\n\r\n\texports.resetDefaultOptions = function () {\r\n\t\tdefaultOptions = {\r\n\t\t\tinclude: _defaultOptions.include.slice(0),\r\n\t\t\tignore: _defaultOptions.ignore.slice(0),\r\n\t\t\tcopy: _defaultOptions.copy.slice(0)\r\n\t\t};\r\n\t};\r\n\r\n\texports.getType = function(x) {\r\n\t\tif ((x) && (typeof (x) === \"object\")) {\r\n\t\t\tif (x.constructor === Date) return \"date\";\r\n\t\t\tif (x.constructor === Array) return \"array\";\r\n\t\t}\r\n\t\treturn typeof x;\r\n\t}\r\n\r\n\tfunction fillOptions(rawOptions, otherOptions) {\r\n\t\tvar options = merge({}, rawOptions);\r\n\r\n\t\t// Move recognized root-level properties into a root namespace\r\n\t\tfor (var i = recognizedRootProperties.length - 1; i >= 0; i--) {\r\n\t\t\tvar property = recognizedRootProperties[i];\r\n\t\t\t\r\n\t\t\t// Carry on, unless this property is present\r\n\t\t\tif (!options[property]) continue;\r\n\t\t\t\r\n\t\t\t// Move the property into the root namespace\r\n\t\t\tif (!(options[\"\"] instanceof Object)) options[\"\"] = {};\r\n\t\t\toptions[\"\"][property] = options[property];\r\n\t\t\tdelete options[property];\r\n\t\t}\r\n\r\n\t\tif (otherOptions) {\r\n\t\t\toptions.ignore = mergeArrays(otherOptions.ignore, options.ignore);\r\n\t\t\toptions.include = mergeArrays(otherOptions.include, options.include);\r\n\t\t\toptions.copy = mergeArrays(otherOptions.copy, options.copy);\r\n\t\t\toptions.observe = mergeArrays(otherOptions.observe, options.observe);\r\n\t\t}\r\n\t\toptions.ignore = mergeArrays(options.ignore, defaultOptions.ignore);\r\n\t\toptions.include = mergeArrays(options.include, defaultOptions.include);\r\n\t\toptions.copy = mergeArrays(options.copy, defaultOptions.copy);\r\n\t\toptions.observe = mergeArrays(options.observe, defaultOptions.observe);\r\n\r\n\t\toptions.mappedProperties = options.mappedProperties || {};\r\n\t\toptions.copiedProperties = options.copiedProperties || {};\r\n\t\treturn options;\r\n\t}\r\n\r\n\tfunction mergeArrays(a, b) {\r\n\t\tif (exports.getType(a) !== \"array\") {\r\n\t\t\tif (exports.getType(a) === \"undefined\") a = [];\r\n\t\t\telse a = [a];\r\n\t\t}\r\n\t\tif (exports.getType(b) !== \"array\") {\r\n\t\t\tif (exports.getType(b) === \"undefined\") b = [];\r\n\t\t\telse b = [b];\r\n\t\t}\r\n\r\n\t\treturn ko.utils.arrayGetDistinctValues(a.concat(b));\r\n\t}\r\n\r\n\t// When using a 'create' callback, we proxy the dependent observable so that it doesn't immediately evaluate on creation.\r\n\t// The reason is that the dependent observables in the user-specified callback may contain references to properties that have not been mapped yet.\r\n\tfunction withProxyDependentObservable(dependentObservables, callback) {\r\n\t\tvar localDO = ko.dependentObservable;\r\n\t\tko.dependentObservable = function (read, owner, options) {\r\n\t\t\toptions = options || {};\r\n\r\n\t\t\tif (read && typeof read == \"object\") { // mirrors condition in knockout implementation of DO's\r\n\t\t\t\toptions = read;\r\n\t\t\t}\r\n\r\n\t\t\tvar realDeferEvaluation = options.deferEvaluation;\r\n\r\n\t\t\tvar isRemoved = false;\r\n\r\n\t\t\t// We wrap the original dependent observable so that we can remove it from the 'dependentObservables' list we need to evaluate after mapping has\r\n\t\t\t// completed if the user already evaluated the DO themselves in the meantime.\r\n\t\t\tvar wrap = function (DO) {\r\n\t\t\t\t// Temporarily revert ko.dependentObservable, since it is used in ko.isWriteableObservable\r\n\t\t\t\tvar tmp = ko.dependentObservable;\r\n\t\t\t\tko.dependentObservable = realKoDependentObservable;\r\n\t\t\t\tvar isWriteable = ko.isWriteableObservable(DO);\r\n\t\t\t\tko.dependentObservable = tmp;\r\n\r\n\t\t\t\tvar wrapped = realKoDependentObservable({\r\n\t\t\t\t\tread: function () {\r\n\t\t\t\t\t\tif (!isRemoved) {\r\n\t\t\t\t\t\t\tko.utils.arrayRemoveItem(dependentObservables, DO);\r\n\t\t\t\t\t\t\tisRemoved = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn DO.apply(DO, arguments);\r\n\t\t\t\t\t},\r\n\t\t\t\t\twrite: isWriteable && function (val) {\r\n\t\t\t\t\t\treturn DO(val);\r\n\t\t\t\t\t},\r\n\t\t\t\t\tdeferEvaluation: true\r\n\t\t\t\t});\r\n\t\t\t\tif (DEBUG) wrapped._wrapper = true;\r\n\t\t\t\treturn wrapped;\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\toptions.deferEvaluation = true; // will either set for just options, or both read/options.\r\n\t\t\tvar realDependentObservable = new realKoDependentObservable(read, owner, options);\r\n\r\n\t\t\tif (!realDeferEvaluation) {\r\n\t\t\t\trealDependentObservable = wrap(realDependentObservable);\r\n\t\t\t\tdependentObservables.push(realDependentObservable);\r\n\t\t\t}\r\n\r\n\t\t\treturn realDependentObservable;\r\n\t\t}\r\n\t\tko.dependentObservable.fn = realKoDependentObservable.fn;\r\n\t\tko.computed = ko.dependentObservable;\r\n\t\tvar result = callback();\r\n\t\tko.dependentObservable = localDO;\r\n\t\tko.computed = ko.dependentObservable;\r\n\t\treturn result;\r\n\t}\r\n\r\n\tfunction updateViewModel(mappedRootObject, rootObject, options, parentName, parent, parentPropertyName, mappedParent) {\r\n\t\tvar isArray = exports.getType(ko.utils.unwrapObservable(rootObject)) === \"array\";\r\n\r\n\t\tparentPropertyName = parentPropertyName || \"\";\r\n\r\n\t\t// If this object was already mapped previously, take the options from there and merge them with our existing ones.\r\n\t\tif (exports.isMapped(mappedRootObject)) {\r\n\t\t\tvar previousMapping = ko.utils.unwrapObservable(mappedRootObject)[mappingProperty];\r\n\t\t\toptions = merge(previousMapping, options);\r\n\t\t}\r\n\r\n\t\tvar callbackParams = {\r\n\t\t\tdata: rootObject,\r\n\t\t\tparent: mappedParent || parent\r\n\t\t};\r\n\r\n\t\tvar hasCreateCallback = function () {\r\n\t\t\treturn options[parentName] && options[parentName].create instanceof Function;\r\n\t\t};\r\n\r\n\t\tvar createCallback = function (data) {\r\n\t\t\treturn withProxyDependentObservable(dependentObservables, function () {\r\n\t\t\t\t\r\n\t\t\t\tif (ko.utils.unwrapObservable(parent) instanceof Array) {\r\n\t\t\t\t\treturn options[parentName].create({\r\n\t\t\t\t\t\tdata: data || callbackParams.data,\r\n\t\t\t\t\t\tparent: callbackParams.parent,\r\n\t\t\t\t\t\tskip: emptyReturn\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn options[parentName].create({\r\n\t\t\t\t\t\tdata: data || callbackParams.data,\r\n\t\t\t\t\t\tparent: callbackParams.parent\r\n\t\t\t\t\t});\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\tvar hasUpdateCallback = function () {\r\n\t\t\treturn options[parentName] && options[parentName].update instanceof Function;\r\n\t\t};\r\n\r\n\t\tvar updateCallback = function (obj, data) {\r\n\t\t\tvar params = {\r\n\t\t\t\tdata: data || callbackParams.data,\r\n\t\t\t\tparent: callbackParams.parent,\r\n\t\t\t\ttarget: ko.utils.unwrapObservable(obj)\r\n\t\t\t};\r\n\r\n\t\t\tif (ko.isWriteableObservable(obj)) {\r\n\t\t\t\tparams.observable = obj;\r\n\t\t\t}\r\n\r\n\t\t\treturn options[parentName].update(params);\r\n\t\t}\r\n\r\n\t\tvar alreadyMapped = visitedObjects.get(rootObject);\r\n\t\tif (alreadyMapped) {\r\n\t\t\treturn alreadyMapped;\r\n\t\t}\r\n\r\n\t\tparentName = parentName || \"\";\r\n\r\n\t\tif (!isArray) {\r\n\t\t\t// For atomic types, do a direct update on the observable\r\n\t\t\tif (!canHaveProperties(rootObject)) {\r\n\t\t\t\tswitch (exports.getType(rootObject)) {\r\n\t\t\t\tcase \"function\":\r\n\t\t\t\t\tif (hasUpdateCallback()) {\r\n\t\t\t\t\t\tif (ko.isWriteableObservable(rootObject)) {\r\n\t\t\t\t\t\t\trootObject(updateCallback(rootObject));\r\n\t\t\t\t\t\t\tmappedRootObject = rootObject;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tmappedRootObject = updateCallback(rootObject);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tmappedRootObject = rootObject;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tif (ko.isWriteableObservable(mappedRootObject)) {\r\n\t\t\t\t\t\tif (hasUpdateCallback()) {\r\n\t\t\t\t\t\t\tvar valueToWrite = updateCallback(mappedRootObject);\r\n\t\t\t\t\t\t\tmappedRootObject(valueToWrite);\r\n\t\t\t\t\t\t\treturn valueToWrite;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvar valueToWrite = ko.utils.unwrapObservable(rootObject);\r\n\t\t\t\t\t\t\tmappedRootObject(valueToWrite);\r\n\t\t\t\t\t\t\treturn valueToWrite;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvar hasCreateOrUpdateCallback = hasCreateCallback() || hasUpdateCallback();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (hasCreateCallback()) {\r\n\t\t\t\t\t\t\tmappedRootObject = createCallback();\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tmappedRootObject = ko.observable(ko.utils.unwrapObservable(rootObject));\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (hasUpdateCallback()) {\r\n\t\t\t\t\t\t\tmappedRootObject(updateCallback(mappedRootObject));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (hasCreateOrUpdateCallback) return mappedRootObject;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\t\t\t\tmappedRootObject = ko.utils.unwrapObservable(mappedRootObject);\r\n\t\t\t\tif (!mappedRootObject) {\r\n\t\t\t\t\tif (hasCreateCallback()) {\r\n\t\t\t\t\t\tvar result = createCallback();\r\n\r\n\t\t\t\t\t\tif (hasUpdateCallback()) {\r\n\t\t\t\t\t\t\tresult = updateCallback(result);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (hasUpdateCallback()) {\r\n\t\t\t\t\t\t\treturn updateCallback(result);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tmappedRootObject = {};\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (hasUpdateCallback()) {\r\n\t\t\t\t\tmappedRootObject = updateCallback(mappedRootObject);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvisitedObjects.save(rootObject, mappedRootObject);\r\n\t\t\t\tif (hasUpdateCallback()) return mappedRootObject;\r\n\r\n\t\t\t\t// For non-atomic types, visit all properties and update recursively\r\n\t\t\t\tvisitPropertiesOrArrayEntries(rootObject, function (indexer) {\r\n\t\t\t\t\tvar fullPropertyName = parentPropertyName.length ? parentPropertyName + \".\" + indexer : indexer;\r\n\r\n\t\t\t\t\tif (ko.utils.arrayIndexOf(options.ignore, fullPropertyName) != -1) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (ko.utils.arrayIndexOf(options.copy, fullPropertyName) != -1) {\r\n\t\t\t\t\t\tmappedRootObject[indexer] = rootObject[indexer];\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(typeof rootObject[indexer] != \"object\" && typeof rootObject[indexer] != \"array\" && options.observe.length > 0 && ko.utils.arrayIndexOf(options.observe, fullPropertyName) == -1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmappedRootObject[indexer] = rootObject[indexer];\r\n\t\t\t\t\t\toptions.copiedProperties[fullPropertyName] = true;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// In case we are adding an already mapped property, fill it with the previously mapped property value to prevent recursion.\r\n\t\t\t\t\t// If this is a property that was generated by fromJS, we should use the options specified there\r\n\t\t\t\t\tvar prevMappedProperty = visitedObjects.get(rootObject[indexer]);\r\n\t\t\t\t\tvar retval = updateViewModel(mappedRootObject[indexer], rootObject[indexer], options, indexer, mappedRootObject, fullPropertyName, mappedRootObject);\r\n\t\t\t\t\tvar value = prevMappedProperty || retval;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(options.observe.length > 0 && ko.utils.arrayIndexOf(options.observe, fullPropertyName) == -1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmappedRootObject[indexer] = value();\r\n\t\t\t\t\t\toptions.copiedProperties[fullPropertyName] = true;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (ko.isWriteableObservable(mappedRootObject[indexer])) {\r\n\t\t\t\t\t\tmappedRootObject[indexer](ko.utils.unwrapObservable(value));\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvalue = mappedRootObject[indexer] === undefined ? value : ko.utils.unwrapObservable(value);\r\n\t\t\t\t\t\tmappedRootObject[indexer] = value;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\toptions.mappedProperties[fullPropertyName] = true;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t} else { //mappedRootObject is an array\r\n\t\t\tvar changes = [];\r\n\r\n\t\t\tvar hasKeyCallback = false;\r\n\t\t\tvar keyCallback = function (x) {\r\n\t\t\t\treturn x;\r\n\t\t\t}\r\n\t\t\tif (options[parentName] && options[parentName].key) {\r\n\t\t\t\tkeyCallback = options[parentName].key;\r\n\t\t\t\thasKeyCallback = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (!ko.isObservable(mappedRootObject)) {\r\n\t\t\t\t// When creating the new observable array, also add a bunch of utility functions that take the 'key' of the array items into account.\r\n\t\t\t\tmappedRootObject = ko.observableArray([]);\r\n\r\n\t\t\t\tmappedRootObject.mappedRemove = function (valueOrPredicate) {\r\n\t\t\t\t\tvar predicate = typeof valueOrPredicate == \"function\" ? valueOrPredicate : function (value) {\r\n\t\t\t\t\t\t\treturn value === keyCallback(valueOrPredicate);\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\treturn mappedRootObject.remove(function (item) {\r\n\t\t\t\t\t\treturn predicate(keyCallback(item));\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmappedRootObject.mappedRemoveAll = function (arrayOfValues) {\r\n\t\t\t\t\tvar arrayOfKeys = filterArrayByKey(arrayOfValues, keyCallback);\r\n\t\t\t\t\treturn mappedRootObject.remove(function (item) {\r\n\t\t\t\t\t\treturn ko.utils.arrayIndexOf(arrayOfKeys, keyCallback(item)) != -1;\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmappedRootObject.mappedDestroy = function (valueOrPredicate) {\r\n\t\t\t\t\tvar predicate = typeof valueOrPredicate == \"function\" ? valueOrPredicate : function (value) {\r\n\t\t\t\t\t\t\treturn value === keyCallback(valueOrPredicate);\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\treturn mappedRootObject.destroy(function (item) {\r\n\t\t\t\t\t\treturn predicate(keyCallback(item));\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmappedRootObject.mappedDestroyAll = function (arrayOfValues) {\r\n\t\t\t\t\tvar arrayOfKeys = filterArrayByKey(arrayOfValues, keyCallback);\r\n\t\t\t\t\treturn mappedRootObject.destroy(function (item) {\r\n\t\t\t\t\t\treturn ko.utils.arrayIndexOf(arrayOfKeys, keyCallback(item)) != -1;\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmappedRootObject.mappedIndexOf = function (item) {\r\n\t\t\t\t\tvar keys = filterArrayByKey(mappedRootObject(), keyCallback);\r\n\t\t\t\t\tvar key = keyCallback(item);\r\n\t\t\t\t\treturn ko.utils.arrayIndexOf(keys, key);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmappedRootObject.mappedCreate = function (value) {\r\n\t\t\t\t\tif (mappedRootObject.mappedIndexOf(value) !== -1) {\r\n\t\t\t\t\t\tthrow new Error(\"There already is an object with the key that you specified.\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar item = hasCreateCallback() ? createCallback(value) : value;\r\n\t\t\t\t\tif (hasUpdateCallback()) {\r\n\t\t\t\t\t\tvar newValue = updateCallback(item, value);\r\n\t\t\t\t\t\tif (ko.isWriteableObservable(item)) {\r\n\t\t\t\t\t\t\titem(newValue);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\titem = newValue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmappedRootObject.push(item);\r\n\t\t\t\t\treturn item;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar currentArrayKeys = filterArrayByKey(ko.utils.unwrapObservable(mappedRootObject), keyCallback).sort();\r\n\t\t\tvar newArrayKeys = filterArrayByKey(rootObject, keyCallback);\r\n\t\t\tif (hasKeyCallback) newArrayKeys.sort();\r\n\t\t\tvar editScript = ko.utils.compareArrays(currentArrayKeys, newArrayKeys);\r\n\r\n\t\t\tvar ignoreIndexOf = {};\r\n\t\t\t\r\n\t\t\tvar i, j;\r\n\r\n\t\t\tvar unwrappedRootObject = ko.utils.unwrapObservable(rootObject);\r\n\t\t\tvar itemsByKey = {};\r\n\t\t\tvar optimizedKeys = true;\r\n\t\t\tfor (i = 0, j = unwrappedRootObject.length; i < j; i++) {\r\n\t\t\t\tvar key = keyCallback(unwrappedRootObject[i]);\r\n\t\t\t\tif (key === undefined || key instanceof Object) {\r\n\t\t\t\t\toptimizedKeys = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\titemsByKey[key] = unwrappedRootObject[i];\r\n\t\t\t}\r\n\r\n\t\t\tvar newContents = [];\r\n\t\t\tvar passedOver = 0;\r\n\t\t\tfor (i = 0, j = editScript.length; i < j; i++) {\r\n\t\t\t\tvar key = editScript[i];\r\n\t\t\t\tvar mappedItem;\r\n\t\t\t\tvar fullPropertyName = parentPropertyName + \"[\" + i + \"]\";\r\n\t\t\t\tswitch (key.status) {\r\n\t\t\t\tcase \"added\":\r\n\t\t\t\t\tvar item = optimizedKeys ? itemsByKey[key.value] : getItemByKey(ko.utils.unwrapObservable(rootObject), key.value, keyCallback);\r\n\t\t\t\t\tmappedItem = updateViewModel(undefined, item, options, parentName, mappedRootObject, fullPropertyName, parent);\r\n\t\t\t\t\tif(!hasCreateCallback()) {\r\n\t\t\t\t\t\tmappedItem = ko.utils.unwrapObservable(mappedItem);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar index = ignorableIndexOf(ko.utils.unwrapObservable(rootObject), item, ignoreIndexOf);\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (mappedItem === emptyReturn) {\r\n\t\t\t\t\t\tpassedOver++;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnewContents[index - passedOver] = mappedItem;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tignoreIndexOf[index] = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"retained\":\r\n\t\t\t\t\tvar item = optimizedKeys ? itemsByKey[key.value] : getItemByKey(ko.utils.unwrapObservable(rootObject), key.value, keyCallback);\r\n\t\t\t\t\tmappedItem = getItemByKey(mappedRootObject, key.value, keyCallback);\r\n\t\t\t\t\tupdateViewModel(mappedItem, item, options, parentName, mappedRootObject, fullPropertyName, parent);\r\n\r\n\t\t\t\t\tvar index = ignorableIndexOf(ko.utils.unwrapObservable(rootObject), item, ignoreIndexOf);\r\n\t\t\t\t\tnewContents[index] = mappedItem;\r\n\t\t\t\t\tignoreIndexOf[index] = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"deleted\":\r\n\t\t\t\t\tmappedItem = getItemByKey(mappedRootObject, key.value, keyCallback);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tchanges.push({\r\n\t\t\t\t\tevent: key.status,\r\n\t\t\t\t\titem: mappedItem\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tmappedRootObject(newContents);\r\n\r\n\t\t\tif (options[parentName] && options[parentName].arrayChanged) {\r\n\t\t\t\tko.utils.arrayForEach(changes, function (change) {\r\n\t\t\t\t\toptions[parentName].arrayChanged(change.event, change.item);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn mappedRootObject;\r\n\t}\r\n\r\n\tfunction ignorableIndexOf(array, item, ignoreIndices) {\r\n\t\tfor (var i = 0, j = array.length; i < j; i++) {\r\n\t\t\tif (ignoreIndices[i] === true) continue;\r\n\t\t\tif (array[i] === item) return i;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tfunction mapKey(item, callback) {\r\n\t\tvar mappedItem;\r\n\t\tif (callback) mappedItem = callback(item);\r\n\t\tif (exports.getType(mappedItem) === \"undefined\") mappedItem = item;\r\n\r\n\t\treturn ko.utils.unwrapObservable(mappedItem);\r\n\t}\r\n\r\n\tfunction getItemByKey(array, key, callback) {\r\n\t\tarray = ko.utils.unwrapObservable(array);\r\n\t\tfor (var i = 0, j = array.length; i < j; i++) {\r\n\t\t\tvar item = array[i];\r\n\t\t\tif (mapKey(item, callback) === key) return item;\r\n\t\t}\r\n\r\n\t\tthrow new Error(\"When calling ko.update*, the key '\" + key + \"' was not found!\");\r\n\t}\r\n\r\n\tfunction filterArrayByKey(array, callback) {\r\n\t\treturn ko.utils.arrayMap(ko.utils.unwrapObservable(array), function (item) {\r\n\t\t\tif (callback) {\r\n\t\t\t\treturn mapKey(item, callback);\r\n\t\t\t} else {\r\n\t\t\t\treturn item;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tfunction visitPropertiesOrArrayEntries(rootObject, visitorCallback) {\r\n\t\tif (exports.getType(rootObject) === \"array\") {\r\n\t\t\tfor (var i = 0; i < rootObject.length; i++)\r\n\t\t\tvisitorCallback(i);\r\n\t\t} else {\r\n\t\t\tfor (var propertyName in rootObject)\r\n\t\t\tvisitorCallback(propertyName);\r\n\t\t}\r\n\t};\r\n\r\n\tfunction canHaveProperties(object) {\r\n\t\tvar type = exports.getType(object);\r\n\t\treturn ((type === \"object\") || (type === \"array\")) && (object !== null);\r\n\t}\r\n\r\n\t// Based on the parentName, this creates a fully classified name of a property\r\n\r\n\tfunction getPropertyName(parentName, parent, indexer) {\r\n\t\tvar propertyName = parentName || \"\";\r\n\t\tif (exports.getType(parent) === \"array\") {\r\n\t\t\tif (parentName) {\r\n\t\t\t\tpropertyName += \"[\" + indexer + \"]\";\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (parentName) {\r\n\t\t\t\tpropertyName += \".\";\r\n\t\t\t}\r\n\t\t\tpropertyName += indexer;\r\n\t\t}\r\n\t\treturn propertyName;\r\n\t}\r\n\r\n\texports.visitModel = function (rootObject, callback, options) {\r\n\t\toptions = options || {};\r\n\t\toptions.visitedObjects = options.visitedObjects || new objectLookup();\r\n\r\n\t\tvar mappedRootObject;\r\n\t\tvar unwrappedRootObject = ko.utils.unwrapObservable(rootObject);\r\n\r\n\t\tif (!canHaveProperties(unwrappedRootObject)) {\r\n\t\t\treturn callback(rootObject, options.parentName);\r\n\t\t} else {\r\n\t\t\toptions = fillOptions(options, unwrappedRootObject[mappingProperty]);\r\n\r\n\t\t\t// Only do a callback, but ignore the results\r\n\t\t\tcallback(rootObject, options.parentName);\r\n\t\t\tmappedRootObject = exports.getType(unwrappedRootObject) === \"array\" ? [] : {};\r\n\t\t}\r\n\r\n\t\toptions.visitedObjects.save(rootObject, mappedRootObject);\r\n\r\n\t\tvar parentName = options.parentName;\r\n\t\tvisitPropertiesOrArrayEntries(unwrappedRootObject, function (indexer) {\r\n\t\t\tif (options.ignore && ko.utils.arrayIndexOf(options.ignore, indexer) != -1) return;\r\n\r\n\t\t\tvar propertyValue = unwrappedRootObject[indexer];\r\n\t\t\toptions.parentName = getPropertyName(parentName, unwrappedRootObject, indexer);\r\n\r\n\t\t\t// If we don't want to explicitly copy the unmapped property...\r\n\t\t\tif (ko.utils.arrayIndexOf(options.copy, indexer) === -1) {\r\n\t\t\t\t// ...find out if it's a property we want to explicitly include\r\n\t\t\t\tif (ko.utils.arrayIndexOf(options.include, indexer) === -1) {\r\n\t\t\t\t\t// The mapped properties object contains all the properties that were part of the original object.\r\n\t\t\t\t\t// If a property does not exist, and it is not because it is part of an array (e.g. \"myProp[3]\"), then it should not be unmapped.\r\n\t\t\t\t    if (unwrappedRootObject[mappingProperty]\r\n\t\t\t\t        && unwrappedRootObject[mappingProperty].mappedProperties && !unwrappedRootObject[mappingProperty].mappedProperties[indexer]\r\n\t\t\t\t        && unwrappedRootObject[mappingProperty].copiedProperties && !unwrappedRootObject[mappingProperty].copiedProperties[indexer]\r\n\t\t\t\t        && !(exports.getType(unwrappedRootObject) === \"array\")) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar outputProperty;\r\n\t\t\tswitch (exports.getType(ko.utils.unwrapObservable(propertyValue))) {\r\n\t\t\tcase \"object\":\r\n\t\t\tcase \"array\":\r\n\t\t\tcase \"undefined\":\r\n\t\t\t\tvar previouslyMappedValue = options.visitedObjects.get(propertyValue);\r\n\t\t\t\tmappedRootObject[indexer] = (exports.getType(previouslyMappedValue) !== \"undefined\") ? previouslyMappedValue : exports.visitModel(propertyValue, callback, options);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tmappedRootObject[indexer] = callback(propertyValue, options.parentName);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn mappedRootObject;\r\n\t}\r\n\r\n\tfunction simpleObjectLookup() {\r\n\t\tvar keys = [];\r\n\t\tvar values = [];\r\n\t\tthis.save = function (key, value) {\r\n\t\t\tvar existingIndex = ko.utils.arrayIndexOf(keys, key);\r\n\t\t\tif (existingIndex >= 0) values[existingIndex] = value;\r\n\t\t\telse {\r\n\t\t\t\tkeys.push(key);\r\n\t\t\t\tvalues.push(value);\r\n\t\t\t}\r\n\t\t};\r\n\t\tthis.get = function (key) {\r\n\t\t\tvar existingIndex = ko.utils.arrayIndexOf(keys, key);\r\n\t\t\tvar value = (existingIndex >= 0) ? values[existingIndex] : undefined;\r\n\t\t\treturn value;\r\n\t\t};\r\n\t};\r\n\t\r\n\tfunction objectLookup() {\r\n\t\tvar buckets = {};\r\n\t\t\r\n\t\tvar findBucket = function(key) {\r\n\t\t\tvar bucketKey;\r\n\t\t\ttry {\r\n\t\t\t\tbucketKey = key;//JSON.stringify(key);\r\n\t\t\t}\r\n\t\t\tcatch (e) {\r\n\t\t\t\tbucketKey = \"$$$\";\r\n\t\t\t}\r\n\r\n\t\t\tvar bucket = buckets[bucketKey];\r\n\t\t\tif (bucket === undefined) {\r\n\t\t\t\tbucket = new simpleObjectLookup();\r\n\t\t\t\tbuckets[bucketKey] = bucket;\r\n\t\t\t}\r\n\t\t\treturn bucket;\r\n\t\t};\r\n\t\t\r\n\t\tthis.save = function (key, value) {\r\n\t\t\tfindBucket(key).save(key, value);\r\n\t\t};\r\n\t\tthis.get = function (key) {\r\n\t\t\treturn findBucket(key).get(key);\r\n\t\t};\r\n\t};\r\n}));\r\n"]}