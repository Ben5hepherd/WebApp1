{"version":3,"sources":["angular-touch.js"],"names":["window","angular","nodeName_","element","lowercase","nodeName","$TouchProvider","$provide","$compileProvider","ngClickOverrideEnabled","ngClickDirectiveAdded","this","enabled","isDefined","ngTouchClickDirectiveFactory","$$moduleName","directive","decorator","$delegate","shift","i","length","splice","$get","makeSwipeDirective","directiveName","direction","eventName","ngTouch","$parse","$swipe","MAX_VERTICAL_DISTANCE","MAX_VERTICAL_RATIO","MIN_HORIZONTAL_DISTANCE","scope","attr","validSwipe","coords","startCoords","deltaY","Math","abs","y","deltaX","x","valid","swipeHandler","pointerTypes","push","bind","start","event","cancel","end","$apply","triggerHandler","$event","module","info","angularVersion","provider","$inject","factory","getCoordinates","originalEvent","touches","e","changedTouches","clientX","clientY","getEvents","eventType","res","forEach","pointerType","POINTER_EVENTS","join","MOVE_BUFFER_RADIUS","mouse","move","touch","pointer","eventHandlers","totalX","totalY","lastPos","active","on","events","preventDefault","$timeout","$rootElement","hit","x1","y1","x2","y2","CLICKBUSTER_THRESHOLD","checkAllowableRegions","touchCoordinates","onClick","Date","now","lastPreventedTime","PREVENT_DURATION","lastLabelClickCoordinates","target","stopPropagation","blur","onTouchStart","preventGhostClick","addEventListener","TAP_DURATION","MOVE_TOLERANCE","ACTIVE_CLASS_NAME","resetState","tapping","removeClass","tapElement","startTime","touchStartX","touchStartY","clickHandler","ngClick","srcElement","nodeType","parentNode","addClass","diff","dist","sqrt","pow","disabled","onclick","touchend"],"mappings":"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","file":"../angular-touch.js","sourcesContent":["/**\n * @license AngularJS v1.6.6\n * (c) 2010-2017 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\n/* global ngTouchClickDirectiveFactory: false */\n\n/**\n * @ngdoc module\n * @name ngTouch\n * @description\n *\n * # ngTouch\n *\n * The `ngTouch` module provides touch events and other helpers for touch-enabled devices.\n * The implementation is based on jQuery Mobile touch event handling\n * ([jquerymobile.com](http://jquerymobile.com/)).\n *\n *\n * See {@link ngTouch.$swipe `$swipe`} for usage.\n *\n * <div doc-module-components=\"ngTouch\"></div>\n *\n */\n\n// define ngTouch module\n/* global -ngTouch */\nvar ngTouch = angular.module('ngTouch', []);\n\nngTouch.info({ angularVersion: '1.6.6' });\n\nngTouch.provider('$touch', $TouchProvider);\n\nfunction nodeName_(element) {\n  return angular.lowercase(element.nodeName || (element[0] && element[0].nodeName));\n}\n\n/**\n * @ngdoc provider\n * @name $touchProvider\n *\n * @description\n * The `$touchProvider` allows enabling / disabling {@link ngTouch.ngClick ngTouch's ngClick directive}.\n */\n$TouchProvider.$inject = ['$provide', '$compileProvider'];\nfunction $TouchProvider($provide, $compileProvider) {\n\n  /**\n   * @ngdoc method\n   * @name  $touchProvider#ngClickOverrideEnabled\n   *\n   * @param {boolean=} enabled update the ngClickOverrideEnabled state if provided, otherwise just return the\n   * current ngClickOverrideEnabled state\n   * @returns {*} current value if used as getter or itself (chaining) if used as setter\n   *\n   * @kind function\n   *\n   * @description\n   * Call this method to enable/disable {@link ngTouch.ngClick ngTouch's ngClick directive}. If enabled,\n   * the default ngClick directive will be replaced by a version that eliminates the 300ms delay for\n   * click events on browser for touch-devices.\n   *\n   * The default is `false`.\n   *\n   */\n  var ngClickOverrideEnabled = false;\n  var ngClickDirectiveAdded = false;\n  // eslint-disable-next-line no-invalid-this\n  this.ngClickOverrideEnabled = function(enabled) {\n    if (angular.isDefined(enabled)) {\n\n      if (enabled && !ngClickDirectiveAdded) {\n        ngClickDirectiveAdded = true;\n\n        // Use this to identify the correct directive in the delegate\n        ngTouchClickDirectiveFactory.$$moduleName = 'ngTouch';\n        $compileProvider.directive('ngClick', ngTouchClickDirectiveFactory);\n\n        $provide.decorator('ngClickDirective', ['$delegate', function($delegate) {\n          if (ngClickOverrideEnabled) {\n            // drop the default ngClick directive\n            $delegate.shift();\n          } else {\n            // drop the ngTouch ngClick directive if the override has been re-disabled (because\n            // we cannot de-register added directives)\n            var i = $delegate.length - 1;\n            while (i >= 0) {\n              if ($delegate[i].$$moduleName === 'ngTouch') {\n                $delegate.splice(i, 1);\n                break;\n              }\n              i--;\n            }\n          }\n\n          return $delegate;\n        }]);\n      }\n\n      ngClickOverrideEnabled = enabled;\n      return this;\n    }\n\n    return ngClickOverrideEnabled;\n  };\n\n  /**\n  * @ngdoc service\n  * @name $touch\n  * @kind object\n  *\n  * @description\n  * Provides the {@link ngTouch.$touch#ngClickOverrideEnabled `ngClickOverrideEnabled`} method.\n  *\n  */\n  // eslint-disable-next-line no-invalid-this\n  this.$get = function() {\n    return {\n      /**\n       * @ngdoc method\n       * @name  $touch#ngClickOverrideEnabled\n       *\n       * @returns {*} current value of `ngClickOverrideEnabled` set in the {@link ngTouch.$touchProvider $touchProvider},\n       * i.e. if {@link ngTouch.ngClick ngTouch's ngClick} directive is enabled.\n       *\n       * @kind function\n       */\n      ngClickOverrideEnabled: function() {\n        return ngClickOverrideEnabled;\n      }\n    };\n  };\n\n}\n\n/* global ngTouch: false */\n\n    /**\n     * @ngdoc service\n     * @name $swipe\n     *\n     * @description\n     * The `$swipe` service is a service that abstracts the messier details of hold-and-drag swipe\n     * behavior, to make implementing swipe-related directives more convenient.\n     *\n     * Requires the {@link ngTouch `ngTouch`} module to be installed.\n     *\n     * `$swipe` is used by the `ngSwipeLeft` and `ngSwipeRight` directives in `ngTouch`.\n     *\n     * # Usage\n     * The `$swipe` service is an object with a single method: `bind`. `bind` takes an element\n     * which is to be watched for swipes, and an object with four handler functions. See the\n     * documentation for `bind` below.\n     */\n\nngTouch.factory('$swipe', [function() {\n  // The total distance in any direction before we make the call on swipe vs. scroll.\n  var MOVE_BUFFER_RADIUS = 10;\n\n  var POINTER_EVENTS = {\n    'mouse': {\n      start: 'mousedown',\n      move: 'mousemove',\n      end: 'mouseup'\n    },\n    'touch': {\n      start: 'touchstart',\n      move: 'touchmove',\n      end: 'touchend',\n      cancel: 'touchcancel'\n    },\n    'pointer': {\n      start: 'pointerdown',\n      move: 'pointermove',\n      end: 'pointerup',\n      cancel: 'pointercancel'\n    }\n  };\n\n  function getCoordinates(event) {\n    var originalEvent = event.originalEvent || event;\n    var touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [originalEvent];\n    var e = (originalEvent.changedTouches && originalEvent.changedTouches[0]) || touches[0];\n\n    return {\n      x: e.clientX,\n      y: e.clientY\n    };\n  }\n\n  function getEvents(pointerTypes, eventType) {\n    var res = [];\n    angular.forEach(pointerTypes, function(pointerType) {\n      var eventName = POINTER_EVENTS[pointerType][eventType];\n      if (eventName) {\n        res.push(eventName);\n      }\n    });\n    return res.join(' ');\n  }\n\n  return {\n    /**\n     * @ngdoc method\n     * @name $swipe#bind\n     *\n     * @description\n     * The main method of `$swipe`. It takes an element to be watched for swipe motions, and an\n     * object containing event handlers.\n     * The pointer types that should be used can be specified via the optional\n     * third argument, which is an array of strings `'mouse'`, `'touch'` and `'pointer'`. By default,\n     * `$swipe` will listen for `mouse`, `touch` and `pointer` events.\n     *\n     * The four events are `start`, `move`, `end`, and `cancel`. `start`, `move`, and `end`\n     * receive as a parameter a coordinates object of the form `{ x: 150, y: 310 }` and the raw\n     * `event`. `cancel` receives the raw `event` as its single parameter.\n     *\n     * `start` is called on either `mousedown`, `touchstart` or `pointerdown`. After this event, `$swipe` is\n     * watching for `touchmove`, `mousemove` or `pointermove` events. These events are ignored until the total\n     * distance moved in either dimension exceeds a small threshold.\n     *\n     * Once this threshold is exceeded, either the horizontal or vertical delta is greater.\n     * - If the horizontal distance is greater, this is a swipe and `move` and `end` events follow.\n     * - If the vertical distance is greater, this is a scroll, and we let the browser take over.\n     *   A `cancel` event is sent.\n     *\n     * `move` is called on `mousemove`, `touchmove` and `pointermove` after the above logic has determined that\n     * a swipe is in progress.\n     *\n     * `end` is called when a swipe is successfully completed with a `touchend`, `mouseup` or `pointerup`.\n     *\n     * `cancel` is called either on a `touchcancel` or `pointercancel`  from the browser, or when we begin scrolling\n     * as described above.\n     *\n     */\n    bind: function(element, eventHandlers, pointerTypes) {\n      // Absolute total movement, used to control swipe vs. scroll.\n      var totalX, totalY;\n      // Coordinates of the start position.\n      var startCoords;\n      // Last event's position.\n      var lastPos;\n      // Whether a swipe is active.\n      var active = false;\n\n      pointerTypes = pointerTypes || ['mouse', 'touch', 'pointer'];\n      element.on(getEvents(pointerTypes, 'start'), function(event) {\n        startCoords = getCoordinates(event);\n        active = true;\n        totalX = 0;\n        totalY = 0;\n        lastPos = startCoords;\n        if (eventHandlers['start']) {\n          eventHandlers['start'](startCoords, event);\n        }\n      });\n      var events = getEvents(pointerTypes, 'cancel');\n      if (events) {\n        element.on(events, function(event) {\n          active = false;\n          if (eventHandlers['cancel']) {\n            eventHandlers['cancel'](event);\n          }\n        });\n      }\n\n      element.on(getEvents(pointerTypes, 'move'), function(event) {\n        if (!active) return;\n\n        // Android will send a touchcancel if it thinks we're starting to scroll.\n        // So when the total distance (+ or - or both) exceeds 10px in either direction,\n        // we either:\n        // - On totalX > totalY, we send preventDefault() and treat this as a swipe.\n        // - On totalY > totalX, we let the browser handle it as a scroll.\n\n        if (!startCoords) return;\n        var coords = getCoordinates(event);\n\n        totalX += Math.abs(coords.x - lastPos.x);\n        totalY += Math.abs(coords.y - lastPos.y);\n\n        lastPos = coords;\n\n        if (totalX < MOVE_BUFFER_RADIUS && totalY < MOVE_BUFFER_RADIUS) {\n          return;\n        }\n\n        // One of totalX or totalY has exceeded the buffer, so decide on swipe vs. scroll.\n        if (totalY > totalX) {\n          // Allow native scrolling to take over.\n          active = false;\n          if (eventHandlers['cancel']) {\n            eventHandlers['cancel'](event);\n          }\n          return;\n        } else {\n          // Prevent the browser from scrolling.\n          event.preventDefault();\n          if (eventHandlers['move']) {\n            eventHandlers['move'](coords, event);\n          }\n        }\n      });\n\n      element.on(getEvents(pointerTypes, 'end'), function(event) {\n        if (!active) return;\n        active = false;\n        if (eventHandlers['end']) {\n          eventHandlers['end'](getCoordinates(event), event);\n        }\n      });\n    }\n  };\n}]);\n\n/* global ngTouch: false,\n  nodeName_: false\n*/\n\n/**\n * @ngdoc directive\n * @name ngClick\n * @deprecated\n * sinceVersion=\"v1.5.0\"\n * This directive is deprecated and **disabled** by default.\n * The directive will receive no further support and might be removed from future releases.\n * If you need the directive, you can enable it with the {@link ngTouch.$touchProvider $touchProvider#ngClickOverrideEnabled}\n * function. We also recommend that you migrate to [FastClick](https://github.com/ftlabs/fastclick).\n * To learn more about the 300ms delay, this [Telerik article](http://developer.telerik.com/featured/300-ms-click-delay-ios-8/)\n * gives a good overview.\n *\n * @description\n * A more powerful replacement for the default ngClick designed to be used on touchscreen\n * devices. Most mobile browsers wait about 300ms after a tap-and-release before sending\n * the click event. This version handles them immediately, and then prevents the\n * following click event from propagating.\n *\n * Requires the {@link ngTouch `ngTouch`} module to be installed.\n *\n * This directive can fall back to using an ordinary click event, and so works on desktop\n * browsers as well as mobile.\n *\n * This directive also sets the CSS class `ng-click-active` while the element is being held\n * down (by a mouse click or touch) so you can restyle the depressed element if you wish.\n *\n * @element ANY\n * @param {expression} ngClick {@link guide/expression Expression} to evaluate\n * upon tap. (Event object is available as `$event`)\n *\n * @example\n    <example module=\"ngClickExample\" deps=\"angular-touch.js\" name=\"ng-touch-ng-click\">\n      <file name=\"index.html\">\n        <button ng-click=\"count = count + 1\" ng-init=\"count=0\">\n          Increment\n        </button>\n        count: {{ count }}\n      </file>\n      <file name=\"script.js\">\n        angular.module('ngClickExample', ['ngTouch']);\n      </file>\n    </example>\n */\n\nvar ngTouchClickDirectiveFactory = ['$parse', '$timeout', '$rootElement',\n    function($parse, $timeout, $rootElement) {\n  var TAP_DURATION = 750; // Shorter than 750ms is a tap, longer is a taphold or drag.\n  var MOVE_TOLERANCE = 12; // 12px seems to work in most mobile browsers.\n  var PREVENT_DURATION = 2500; // 2.5 seconds maximum from preventGhostClick call to click\n  var CLICKBUSTER_THRESHOLD = 25; // 25 pixels in any dimension is the limit for busting clicks.\n\n  var ACTIVE_CLASS_NAME = 'ng-click-active';\n  var lastPreventedTime;\n  var touchCoordinates;\n  var lastLabelClickCoordinates;\n\n\n  // TAP EVENTS AND GHOST CLICKS\n  //\n  // Why tap events?\n  // Mobile browsers detect a tap, then wait a moment (usually ~300ms) to see if you're\n  // double-tapping, and then fire a click event.\n  //\n  // This delay sucks and makes mobile apps feel unresponsive.\n  // So we detect touchstart, touchcancel and touchend ourselves and determine when\n  // the user has tapped on something.\n  //\n  // What happens when the browser then generates a click event?\n  // The browser, of course, also detects the tap and fires a click after a delay. This results in\n  // tapping/clicking twice. We do \"clickbusting\" to prevent it.\n  //\n  // How does it work?\n  // We attach global touchstart and click handlers, that run during the capture (early) phase.\n  // So the sequence for a tap is:\n  // - global touchstart: Sets an \"allowable region\" at the point touched.\n  // - element's touchstart: Starts a touch\n  // (- touchcancel ends the touch, no click follows)\n  // - element's touchend: Determines if the tap is valid (didn't move too far away, didn't hold\n  //   too long) and fires the user's tap handler. The touchend also calls preventGhostClick().\n  // - preventGhostClick() removes the allowable region the global touchstart created.\n  // - The browser generates a click event.\n  // - The global click handler catches the click, and checks whether it was in an allowable region.\n  //     - If preventGhostClick was called, the region will have been removed, the click is busted.\n  //     - If the region is still there, the click proceeds normally. Therefore clicks on links and\n  //       other elements without ngTap on them work normally.\n  //\n  // This is an ugly, terrible hack!\n  // Yeah, tell me about it. The alternatives are using the slow click events, or making our users\n  // deal with the ghost clicks, so I consider this the least of evils. Fortunately Angular\n  // encapsulates this ugly logic away from the user.\n  //\n  // Why not just put click handlers on the element?\n  // We do that too, just to be sure. If the tap event caused the DOM to change,\n  // it is possible another element is now in that position. To take account for these possibly\n  // distinct elements, the handlers are global and care only about coordinates.\n\n  // Checks if the coordinates are close enough to be within the region.\n  function hit(x1, y1, x2, y2) {\n    return Math.abs(x1 - x2) < CLICKBUSTER_THRESHOLD && Math.abs(y1 - y2) < CLICKBUSTER_THRESHOLD;\n  }\n\n  // Checks a list of allowable regions against a click location.\n  // Returns true if the click should be allowed.\n  // Splices out the allowable region from the list after it has been used.\n  function checkAllowableRegions(touchCoordinates, x, y) {\n    for (var i = 0; i < touchCoordinates.length; i += 2) {\n      if (hit(touchCoordinates[i], touchCoordinates[i + 1], x, y)) {\n        touchCoordinates.splice(i, i + 2);\n        return true; // allowable region\n      }\n    }\n    return false; // No allowable region; bust it.\n  }\n\n  // Global click handler that prevents the click if it's in a bustable zone and preventGhostClick\n  // was called recently.\n  function onClick(event) {\n    if (Date.now() - lastPreventedTime > PREVENT_DURATION) {\n      return; // Too old.\n    }\n\n    var touches = event.touches && event.touches.length ? event.touches : [event];\n    var x = touches[0].clientX;\n    var y = touches[0].clientY;\n    // Work around desktop Webkit quirk where clicking a label will fire two clicks (on the label\n    // and on the input element). Depending on the exact browser, this second click we don't want\n    // to bust has either (0,0), negative coordinates, or coordinates equal to triggering label\n    // click event\n    if (x < 1 && y < 1) {\n      return; // offscreen\n    }\n    if (lastLabelClickCoordinates &&\n        lastLabelClickCoordinates[0] === x && lastLabelClickCoordinates[1] === y) {\n      return; // input click triggered by label click\n    }\n    // reset label click coordinates on first subsequent click\n    if (lastLabelClickCoordinates) {\n      lastLabelClickCoordinates = null;\n    }\n    // remember label click coordinates to prevent click busting of trigger click event on input\n    if (nodeName_(event.target) === 'label') {\n      lastLabelClickCoordinates = [x, y];\n    }\n\n    // Look for an allowable region containing this click.\n    // If we find one, that means it was created by touchstart and not removed by\n    // preventGhostClick, so we don't bust it.\n    if (checkAllowableRegions(touchCoordinates, x, y)) {\n      return;\n    }\n\n    // If we didn't find an allowable region, bust the click.\n    event.stopPropagation();\n    event.preventDefault();\n\n    // Blur focused form elements\n    if (event.target && event.target.blur) {\n      event.target.blur();\n    }\n  }\n\n\n  // Global touchstart handler that creates an allowable region for a click event.\n  // This allowable region can be removed by preventGhostClick if we want to bust it.\n  function onTouchStart(event) {\n    var touches = event.touches && event.touches.length ? event.touches : [event];\n    var x = touches[0].clientX;\n    var y = touches[0].clientY;\n    touchCoordinates.push(x, y);\n\n    $timeout(function() {\n      // Remove the allowable region.\n      for (var i = 0; i < touchCoordinates.length; i += 2) {\n        if (touchCoordinates[i] === x && touchCoordinates[i + 1] === y) {\n          touchCoordinates.splice(i, i + 2);\n          return;\n        }\n      }\n    }, PREVENT_DURATION, false);\n  }\n\n  // On the first call, attaches some event handlers. Then whenever it gets called, it creates a\n  // zone around the touchstart where clicks will get busted.\n  function preventGhostClick(x, y) {\n    if (!touchCoordinates) {\n      $rootElement[0].addEventListener('click', onClick, true);\n      $rootElement[0].addEventListener('touchstart', onTouchStart, true);\n      touchCoordinates = [];\n    }\n\n    lastPreventedTime = Date.now();\n\n    checkAllowableRegions(touchCoordinates, x, y);\n  }\n\n  // Actual linking function.\n  return function(scope, element, attr) {\n    var clickHandler = $parse(attr.ngClick),\n        tapping = false,\n        tapElement,  // Used to blur the element after a tap.\n        startTime,   // Used to check if the tap was held too long.\n        touchStartX,\n        touchStartY;\n\n    function resetState() {\n      tapping = false;\n      element.removeClass(ACTIVE_CLASS_NAME);\n    }\n\n    element.on('touchstart', function(event) {\n      tapping = true;\n      tapElement = event.target ? event.target : event.srcElement; // IE uses srcElement.\n      // Hack for Safari, which can target text nodes instead of containers.\n      if (tapElement.nodeType === 3) {\n        tapElement = tapElement.parentNode;\n      }\n\n      element.addClass(ACTIVE_CLASS_NAME);\n\n      startTime = Date.now();\n\n      // Use jQuery originalEvent\n      var originalEvent = event.originalEvent || event;\n      var touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [originalEvent];\n      var e = touches[0];\n      touchStartX = e.clientX;\n      touchStartY = e.clientY;\n    });\n\n    element.on('touchcancel', function(event) {\n      resetState();\n    });\n\n    element.on('touchend', function(event) {\n      var diff = Date.now() - startTime;\n\n      // Use jQuery originalEvent\n      var originalEvent = event.originalEvent || event;\n      var touches = (originalEvent.changedTouches && originalEvent.changedTouches.length) ?\n          originalEvent.changedTouches :\n          ((originalEvent.touches && originalEvent.touches.length) ? originalEvent.touches : [originalEvent]);\n      var e = touches[0];\n      var x = e.clientX;\n      var y = e.clientY;\n      var dist = Math.sqrt(Math.pow(x - touchStartX, 2) + Math.pow(y - touchStartY, 2));\n\n      if (tapping && diff < TAP_DURATION && dist < MOVE_TOLERANCE) {\n        // Call preventGhostClick so the clickbuster will catch the corresponding click.\n        preventGhostClick(x, y);\n\n        // Blur the focused element (the button, probably) before firing the callback.\n        // This doesn't work perfectly on Android Chrome, but seems to work elsewhere.\n        // I couldn't get anything to work reliably on Android Chrome.\n        if (tapElement) {\n          tapElement.blur();\n        }\n\n        if (!angular.isDefined(attr.disabled) || attr.disabled === false) {\n          element.triggerHandler('click', [event]);\n        }\n      }\n\n      resetState();\n    });\n\n    // Hack for iOS Safari's benefit. It goes searching for onclick handlers and is liable to click\n    // something else nearby.\n    element.onclick = function(event) { };\n\n    // Actual click handler.\n    // There are three different kinds of clicks, only two of which reach this point.\n    // - On desktop browsers without touch events, their clicks will always come here.\n    // - On mobile browsers, the simulated \"fast\" click will call this.\n    // - But the browser's follow-up slow click will be \"busted\" before it reaches this handler.\n    // Therefore it's safe to use this directive on both mobile and desktop.\n    element.on('click', function(event, touchend) {\n      scope.$apply(function() {\n        clickHandler(scope, {$event: (touchend || event)});\n      });\n    });\n\n    element.on('mousedown', function(event) {\n      element.addClass(ACTIVE_CLASS_NAME);\n    });\n\n    element.on('mousemove mouseup', function(event) {\n      element.removeClass(ACTIVE_CLASS_NAME);\n    });\n\n  };\n}];\n\n/* global ngTouch: false */\n\n/**\n * @ngdoc directive\n * @name ngSwipeLeft\n *\n * @description\n * Specify custom behavior when an element is swiped to the left on a touchscreen device.\n * A leftward swipe is a quick, right-to-left slide of the finger.\n * Though ngSwipeLeft is designed for touch-based devices, it will work with a mouse click and drag\n * too.\n *\n * To disable the mouse click and drag functionality, add `ng-swipe-disable-mouse` to\n * the `ng-swipe-left` or `ng-swipe-right` DOM Element.\n *\n * Requires the {@link ngTouch `ngTouch`} module to be installed.\n *\n * @element ANY\n * @param {expression} ngSwipeLeft {@link guide/expression Expression} to evaluate\n * upon left swipe. (Event object is available as `$event`)\n *\n * @example\n    <example module=\"ngSwipeLeftExample\" deps=\"angular-touch.js\" name=\"ng-swipe-left\">\n      <file name=\"index.html\">\n        <div ng-show=\"!showActions\" ng-swipe-left=\"showActions = true\">\n          Some list content, like an email in the inbox\n        </div>\n        <div ng-show=\"showActions\" ng-swipe-right=\"showActions = false\">\n          <button ng-click=\"reply()\">Reply</button>\n          <button ng-click=\"delete()\">Delete</button>\n        </div>\n      </file>\n      <file name=\"script.js\">\n        angular.module('ngSwipeLeftExample', ['ngTouch']);\n      </file>\n    </example>\n */\n\n/**\n * @ngdoc directive\n * @name ngSwipeRight\n *\n * @description\n * Specify custom behavior when an element is swiped to the right on a touchscreen device.\n * A rightward swipe is a quick, left-to-right slide of the finger.\n * Though ngSwipeRight is designed for touch-based devices, it will work with a mouse click and drag\n * too.\n *\n * Requires the {@link ngTouch `ngTouch`} module to be installed.\n *\n * @element ANY\n * @param {expression} ngSwipeRight {@link guide/expression Expression} to evaluate\n * upon right swipe. (Event object is available as `$event`)\n *\n * @example\n    <example module=\"ngSwipeRightExample\" deps=\"angular-touch.js\" name=\"ng-swipe-right\">\n      <file name=\"index.html\">\n        <div ng-show=\"!showActions\" ng-swipe-left=\"showActions = true\">\n          Some list content, like an email in the inbox\n        </div>\n        <div ng-show=\"showActions\" ng-swipe-right=\"showActions = false\">\n          <button ng-click=\"reply()\">Reply</button>\n          <button ng-click=\"delete()\">Delete</button>\n        </div>\n      </file>\n      <file name=\"script.js\">\n        angular.module('ngSwipeRightExample', ['ngTouch']);\n      </file>\n    </example>\n */\n\nfunction makeSwipeDirective(directiveName, direction, eventName) {\n  ngTouch.directive(directiveName, ['$parse', '$swipe', function($parse, $swipe) {\n    // The maximum vertical delta for a swipe should be less than 75px.\n    var MAX_VERTICAL_DISTANCE = 75;\n    // Vertical distance should not be more than a fraction of the horizontal distance.\n    var MAX_VERTICAL_RATIO = 0.3;\n    // At least a 30px lateral motion is necessary for a swipe.\n    var MIN_HORIZONTAL_DISTANCE = 30;\n\n    return function(scope, element, attr) {\n      var swipeHandler = $parse(attr[directiveName]);\n\n      var startCoords, valid;\n\n      function validSwipe(coords) {\n        // Check that it's within the coordinates.\n        // Absolute vertical distance must be within tolerances.\n        // Horizontal distance, we take the current X - the starting X.\n        // This is negative for leftward swipes and positive for rightward swipes.\n        // After multiplying by the direction (-1 for left, +1 for right), legal swipes\n        // (ie. same direction as the directive wants) will have a positive delta and\n        // illegal ones a negative delta.\n        // Therefore this delta must be positive, and larger than the minimum.\n        if (!startCoords) return false;\n        var deltaY = Math.abs(coords.y - startCoords.y);\n        var deltaX = (coords.x - startCoords.x) * direction;\n        return valid && // Short circuit for already-invalidated swipes.\n            deltaY < MAX_VERTICAL_DISTANCE &&\n            deltaX > 0 &&\n            deltaX > MIN_HORIZONTAL_DISTANCE &&\n            deltaY / deltaX < MAX_VERTICAL_RATIO;\n      }\n\n      var pointerTypes = ['touch'];\n      if (!angular.isDefined(attr['ngSwipeDisableMouse'])) {\n        pointerTypes.push('mouse');\n      }\n      $swipe.bind(element, {\n        'start': function(coords, event) {\n          startCoords = coords;\n          valid = true;\n        },\n        'cancel': function(event) {\n          valid = false;\n        },\n        'end': function(coords, event) {\n          if (validSwipe(coords)) {\n            scope.$apply(function() {\n              element.triggerHandler(eventName);\n              swipeHandler(scope, {$event: event});\n            });\n          }\n        }\n      }, pointerTypes);\n    };\n  }]);\n}\n\n// Left is negative X-coordinate, right is positive.\nmakeSwipeDirective('ngSwipeLeft', -1, 'swipeleft');\nmakeSwipeDirective('ngSwipeRight', 1, 'swiperight');\n\n\n\n})(window, window.angular);\n"]}