{"version":3,"sources":["knockout.validation.js"],"names":["factory","require","exports","module","define","ko","validation","minMaxValidatorFactory","validatorName","isMaxValidation","val","options","kv","utils","isEmptyVal","comparisonValue","type","undefined","typeAttr","value","isNaN","Date","regex","valMatches","comparisonValueMatches","toLowerCase","match","Error","parseFloat","validateSync","observable","rule","ctx","validator","params","unwrap","setError","formatMessage","message","validateAsync","isValidating","callBack","valObj","isValid","msg","__valid__","error","async","koUtils","unwrapObservable","forEach","arrayForEach","extend","defaults","registerExtenders","messagesOnModified","errorsAsTitle","errorsAsTitleOnModified","messageTemplate","insertMessages","parseInputAttributes","writeInputAttributes","decorateInputElement","decorateElementOnModified","errorClass","errorElementClass","errorMessageClass","allowHtmlMessages","grouping","deep","live","validate","configuration","html5Attributes","html5InputTypes","reset","seedId","getTime","domData","domDataKey","isArray","o","Object","prototype","toString","call","isObject","isNumber","isObservableArray","instance","values","r","i","hasOwnProperty","push","getValue","hasAttribute","node","attr","getAttribute","element","setAttribute","isValidatable","rules","isModified","insertAfter","newNode","parentNode","insertBefore","nextSibling","newId","getConfigOptions","contextFor","setDomData","data","key","getDomData","nodeType","context","getOriginalElementTitle","savedOriginalTitle","currentTitle","title","hasSavedOriginalTitle","expr","window","setImmediate","setTimeout","object","callback","prop","api","cleanUpSubscriptions","subscriptions","subscription","dispose","flagged","obj","__kv_traversed","length","runTraversal","validatables","traverseGraph","level","objValues","peek","isObservable","errors","validatable","subscribe","graphMonitor","valueHasMutated","_destroy","isComputed","collectErrors","array","isInitialized","init","force","group","result","computed","showAllMessages","show","isAnyMessageShown","invalidAndModifiedPresent","find","filter","predicate","arrayFilter","arrayFirst","map","mapping","item","arrayMap","_updateState","newValue","replacements","replace","index","addRule","hasRule","addAnonymousRule","ruleObj","onlyIf","condition","addExtender","ruleName","extenders","insertValidationMessage","span","document","createElement","className","parseInputValidationAttributes","valueAccessor","currentType","writeInputValidationAttributes","contexts","read","RegExp","source","disposeWhenNodeIsRemoved","makeBindingHandlerValidatable","handlerName","bindingHandlers","allBindingsAccessor","viewModel","bindingContext","setRules","target","definition","ruleDefinitions","targetValue","unwrappedTargetValue","nonRules","required","testVal","String","trim","minLength","normalizedVal","maxLength","step","dif","Math","abs","test","phoneNumber","otherValue","c","collection","external","externalValue","counter","config","validationMessageElement","renderTemplate","field","applyBindingsToNode","validationMessage","validationElement","textInput","update","obsv","isVisible","isCurrentlyVisible","style","display","setHtml","text","cssSettingsAccessor","css","shouldShow","hasModification","data-orig-title","newConfig","enable","validationOptions","throttleEvaluation","throttle","observableArray","previousError","previousIsValid","notifySubscribers","clearError","h_change","h_obsValidationTrigger","validateObservable","_disposeValidation","removeAll","ruleContexts","len","_currentLocale","_locales","defineLocale","name","locale","localize","msgTranslations","localeData","applyBindingsWithValidation","rootNode","body","applyBindings","origApplyBindings","validatedObservable","initialValue"],"mappings":"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","file":"../knockout.validation.js","sourcesContent":["/*=============================================================================\n\tAuthor:\t\t\tEric M. Barnard - @ericmbarnard\t\t\t\t\t\t\t\t\n\tLicense:\t\tMIT (http://opensource.org/licenses/mit-license.php)\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tDescription:\tValidation Library for KnockoutJS\t\t\t\t\t\t\t\n\tVersion:\t\t2.0.3\t\t\t\t\t\t\t\t\t\t\t\n===============================================================================\n*/\n/*globals require: false, exports: false, define: false, ko: false */\n\n(function (factory) {\n\t// Module systems magic dance.\n\n\tif (typeof require === \"function\" && typeof exports === \"object\" && typeof module === \"object\") {\n\t\t// CommonJS or Node: hard-coded dependency on \"knockout\"\n\t\tfactory(require(\"knockout\"), exports);\n\t} else if (typeof define === \"function\" && define[\"amd\"]) {\n\t\t// AMD anonymous module with hard-coded dependency on \"knockout\"\n\t\tdefine([\"knockout\", \"exports\"], factory);\n\t} else {\n\t\t// <script> tag: use the global `ko` object, attaching a `mapping` property\n\t\tfactory(ko, ko.validation = {});\n\t}\n}(function ( ko, exports ) {\n\n\tif (typeof (ko) === 'undefined') {\n\t\tthrow new Error('Knockout is required, please ensure it is loaded before loading this validation plug-in');\n\t}\n\n\t// create our namespace object\n\tko.validation = exports;\n\n\tvar kv = ko.validation,\n\t\tkoUtils = ko.utils,\n\t\tunwrap = koUtils.unwrapObservable,\n\t\tforEach = koUtils.arrayForEach,\n\t\textend = koUtils.extend;\n;/*global ko: false*/\n\nvar defaults = {\n\tregisterExtenders: true,\n\tmessagesOnModified: true,\n\terrorsAsTitle: true,            // enables/disables showing of errors as title attribute of the target element.\n\terrorsAsTitleOnModified: false, // shows the error when hovering the input field (decorateElement must be true)\n\tmessageTemplate: null,\n\tinsertMessages: true,           // automatically inserts validation messages as <span></span>\n\tparseInputAttributes: false,    // parses the HTML5 validation attribute from a form element and adds that to the object\n\twriteInputAttributes: false,    // adds HTML5 input validation attributes to form elements that ko observable's are bound to\n\tdecorateInputElement: false,         // false to keep backward compatibility\n\tdecorateElementOnModified: true,// true to keep backward compatibility\n\terrorClass: null,               // single class for error message and element\n\terrorElementClass: 'validationElement',  // class to decorate error element\n\terrorMessageClass: 'validationMessage',  // class to decorate error message\n\tallowHtmlMessages: false,\t\t// allows HTML in validation messages\n\tgrouping: {\n\t\tdeep: false,        //by default grouping is shallow\n\t\tobservable: true,   //and using observables\n\t\tlive: false\t\t    //react to changes to observableArrays if observable === true\n\t},\n\tvalidate: {\n\t\t// throttle: 10\n\t}\n};\n\n// make a copy  so we can use 'reset' later\nvar configuration = extend({}, defaults);\n\nconfiguration.html5Attributes = ['required', 'pattern', 'min', 'max', 'step'];\nconfiguration.html5InputTypes = ['email', 'number', 'date'];\n\nconfiguration.reset = function () {\n\textend(configuration, defaults);\n};\n\nkv.configuration = configuration;\n;kv.utils = (function () {\n\tvar seedId = new Date().getTime();\n\n\tvar domData = {}; //hash of data objects that we reference from dom elements\n\tvar domDataKey = '__ko_validation__';\n\n\treturn {\n\t\tisArray: function (o) {\n\t\t\treturn o.isArray || Object.prototype.toString.call(o) === '[object Array]';\n\t\t},\n\t\tisObject: function (o) {\n\t\t\treturn o !== null && typeof o === 'object';\n\t\t},\n\t\tisNumber: function(o) {\n\t\t\treturn !isNaN(o);\t\n\t\t},\n\t\tisObservableArray: function(instance) {\n\t\t\treturn !!instance &&\n\t\t\t\t\ttypeof instance[\"remove\"] === \"function\" &&\n\t\t\t\t\ttypeof instance[\"removeAll\"] === \"function\" &&\n\t\t\t\t\ttypeof instance[\"destroy\"] === \"function\" &&\n\t\t\t\t\ttypeof instance[\"destroyAll\"] === \"function\" &&\n\t\t\t\t\ttypeof instance[\"indexOf\"] === \"function\" &&\n\t\t\t\t\ttypeof instance[\"replace\"] === \"function\";\n\t\t},\n\t\tvalues: function (o) {\n\t\t\tvar r = [];\n\t\t\tfor (var i in o) {\n\t\t\t\tif (o.hasOwnProperty(i)) {\n\t\t\t\t\tr.push(o[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn r;\n\t\t},\n\t\tgetValue: function (o) {\n\t\t\treturn (typeof o === 'function' ? o() : o);\n\t\t},\n\t\thasAttribute: function (node, attr) {\n\t\t\treturn node.getAttribute(attr) !== null;\n\t\t},\n\t\tgetAttribute: function (element, attr) {\n\t\t\treturn element.getAttribute(attr);\n\t\t},\n\t\tsetAttribute: function (element, attr, value) {\n\t\t\treturn element.setAttribute(attr, value);\n\t\t},\n\t\tisValidatable: function (o) {\n\t\t\treturn !!(o && o.rules && o.isValid && o.isModified);\n\t\t},\n\t\tinsertAfter: function (node, newNode) {\n\t\t\tnode.parentNode.insertBefore(newNode, node.nextSibling);\n\t\t},\n\t\tnewId: function () {\n\t\t\treturn seedId += 1;\n\t\t},\n\t\tgetConfigOptions: function (element) {\n\t\t\tvar options = kv.utils.contextFor(element);\n\n\t\t\treturn options || kv.configuration;\n\t\t},\n\t\tsetDomData: function (node, data) {\n\t\t\tvar key = node[domDataKey];\n\n\t\t\tif (!key) {\n\t\t\t\tnode[domDataKey] = key = kv.utils.newId();\n\t\t\t}\n\n\t\t\tdomData[key] = data;\n\t\t},\n\t\tgetDomData: function (node) {\n\t\t\tvar key = node[domDataKey];\n\n\t\t\tif (!key) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\treturn domData[key];\n\t\t},\n\t\tcontextFor: function (node) {\n\t\t\tswitch (node.nodeType) {\n\t\t\t\tcase 1:\n\t\t\t\tcase 8:\n\t\t\t\t\tvar context = kv.utils.getDomData(node);\n\t\t\t\t\tif (context) { return context; }\n\t\t\t\t\tif (node.parentNode) { return kv.utils.contextFor(node.parentNode); }\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn undefined;\n\t\t},\n\t\tisEmptyVal: function (val) {\n\t\t\tif (val === undefined) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (val === null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (val === \"\") {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tgetOriginalElementTitle: function (element) {\n\t\t\tvar savedOriginalTitle = kv.utils.getAttribute(element, 'data-orig-title'),\n\t\t\t\tcurrentTitle = element.title,\n\t\t\t\thasSavedOriginalTitle = kv.utils.hasAttribute(element, 'data-orig-title');\n\n\t\t\treturn hasSavedOriginalTitle ?\n\t\t\t\tsavedOriginalTitle : currentTitle;\n\t\t},\n\t\tasync: function (expr) {\n\t\t\tif (window.setImmediate) { window.setImmediate(expr); }\n\t\t\telse { window.setTimeout(expr, 0); }\n\t\t},\n\t\tforEach: function (object, callback) {\n\t\t\tif (kv.utils.isArray(object)) {\n\t\t\t\treturn forEach(object, callback);\n\t\t\t}\n\t\t\tfor (var prop in object) {\n\t\t\t\tif (object.hasOwnProperty(prop)) {\n\t\t\t\t\tcallback(object[prop], prop);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}());;var api = (function () {\n\n\tvar isInitialized = 0,\n\t\tconfiguration = kv.configuration,\n\t\tutils = kv.utils;\n\n\tfunction cleanUpSubscriptions(context) {\n\t\tforEach(context.subscriptions, function (subscription) {\n\t\t\tsubscription.dispose();\n\t\t});\n\t\tcontext.subscriptions = [];\n\t}\n\n\tfunction dispose(context) {\n\t\tif (context.options.deep) {\n\t\t\tforEach(context.flagged, function (obj) {\n\t\t\t\tdelete obj.__kv_traversed;\n\t\t\t});\n\t\t\tcontext.flagged.length = 0;\n\t\t}\n\n\t\tif (!context.options.live) {\n\t\t\tcleanUpSubscriptions(context);\n\t\t}\n\t}\n\n\tfunction runTraversal(obj, context) {\n\t\tcontext.validatables = [];\n\t\tcleanUpSubscriptions(context);\n\t\ttraverseGraph(obj, context);\n\t\tdispose(context);\n\t}\n\n\tfunction traverseGraph(obj, context, level) {\n\t\tvar objValues = [],\n\t\t\tval = obj.peek ? obj.peek() : obj;\n\n\t\tif (obj.__kv_traversed === true) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (context.options.deep) {\n\t\t\tobj.__kv_traversed = true;\n\t\t\tcontext.flagged.push(obj);\n\t\t}\n\n\t\t//default level value depends on deep option.\n\t\tlevel = (level !== undefined ? level : context.options.deep ? 1 : -1);\n\n\t\t// if object is observable then add it to the list\n\t\tif (ko.isObservable(obj)) {\n\t\t\t// ensure it's validatable but don't extend validatedObservable because it\n\t\t\t// would overwrite isValid property.\n\t\t\tif (!obj.errors && !utils.isValidatable(obj)) {\n\t\t\t\tobj.extend({ validatable: true });\n\t\t\t}\n\t\t\tcontext.validatables.push(obj);\n\n\t\t\tif (context.options.live && utils.isObservableArray(obj)) {\n\t\t\t\tcontext.subscriptions.push(obj.subscribe(function () {\n\t\t\t\t\tcontext.graphMonitor.valueHasMutated();\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\n\t\t//get list of values either from array or object but ignore non-objects\n\t\t// and destroyed objects\n\t\tif (val && !val._destroy) {\n\t\t\tif (utils.isArray(val)) {\n\t\t\t\tobjValues = val;\n\t\t\t}\n\t\t\telse if (utils.isObject(val)) {\n\t\t\t\tobjValues = utils.values(val);\n\t\t\t}\n\t\t}\n\n\t\t//process recursively if it is deep grouping\n\t\tif (level !== 0) {\n\t\t\tutils.forEach(objValues, function (observable) {\n\t\t\t\t//but not falsy things and not HTML Elements\n\t\t\t\tif (observable && !observable.nodeType && (!ko.isComputed(observable) || observable.rules)) {\n\t\t\t\t\ttraverseGraph(observable, context, level + 1);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction collectErrors(array) {\n\t\tvar errors = [];\n\t\tforEach(array, function (observable) {\n\t\t\t// Do not collect validatedObservable errors\n\t\t\tif (utils.isValidatable(observable) && !observable.isValid()) {\n\t\t\t\t// Use peek because we don't want a dependency for 'error' property because it\n\t\t\t\t// changes before 'isValid' does. (Issue #99)\n\t\t\t\terrors.push(observable.error.peek());\n\t\t\t}\n\t\t});\n\t\treturn errors;\n\t}\n\n\treturn {\n\t\t//Call this on startup\n\t\t//any config can be overridden with the passed in options\n\t\tinit: function (options, force) {\n\t\t\t//done run this multiple times if we don't really want to\n\t\t\tif (isInitialized > 0 && !force) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//because we will be accessing options properties it has to be an object at least\n\t\t\toptions = options || {};\n\t\t\t//if specific error classes are not provided then apply generic errorClass\n\t\t\t//it has to be done on option so that options.errorClass can override default\n\t\t\t//errorElementClass and errorMessage class but not those provided in options\n\t\t\toptions.errorElementClass = options.errorElementClass || options.errorClass || configuration.errorElementClass;\n\t\t\toptions.errorMessageClass = options.errorMessageClass || options.errorClass || configuration.errorMessageClass;\n\n\t\t\textend(configuration, options);\n\n\t\t\tif (configuration.registerExtenders) {\n\t\t\t\tkv.registerExtenders();\n\t\t\t}\n\n\t\t\tisInitialized = 1;\n\t\t},\n\n\t\t// resets the config back to its original state\n\t\treset: kv.configuration.reset,\n\n\t\t// recursively walks a viewModel and creates an object that\n\t\t// provides validation information for the entire viewModel\n\t\t// obj -> the viewModel to walk\n\t\t// options -> {\n\t\t//\t  deep: false, // if true, will walk past the first level of viewModel properties\n\t\t//\t  observable: false // if true, returns a computed observable indicating if the viewModel is valid\n\t\t// }\n\t\tgroup: function group(obj, options) { // array of observables or viewModel\n\t\t\toptions = extend(extend({}, configuration.grouping), options);\n\n\t\t\tvar context = {\n\t\t\t\toptions: options,\n\t\t\t\tgraphMonitor: ko.observable(),\n\t\t\t\tflagged: [],\n\t\t\t\tsubscriptions: [],\n\t\t\t\tvalidatables: []\n\t\t\t};\n\n\t\t\tvar result = null;\n\n\t\t\t//if using observables then traverse structure once and add observables\n\t\t\tif (options.observable) {\n\t\t\t\tresult = ko.computed(function () {\n\t\t\t\t\tcontext.graphMonitor(); //register dependency\n\t\t\t\t\trunTraversal(obj, context);\n\t\t\t\t\treturn collectErrors(context.validatables);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse { //if not using observables then every call to error() should traverse the structure\n\t\t\t\tresult = function () {\n\t\t\t\t\trunTraversal(obj, context);\n\t\t\t\t\treturn collectErrors(context.validatables);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tresult.showAllMessages = function (show) { // thanks @heliosPortal\n\t\t\t\tif (show === undefined) {//default to true\n\t\t\t\t\tshow = true;\n\t\t\t\t}\n\n\t\t\t\tresult.forEach(function (observable) {\n\t\t\t\t\tif (utils.isValidatable(observable)) {\n\t\t\t\t\t\tobservable.isModified(show);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tresult.isAnyMessageShown = function () {\n\t\t\t\tvar invalidAndModifiedPresent;\n\n\t\t\t\tinvalidAndModifiedPresent = !!result.find(function (observable) {\n\t\t\t\t\treturn utils.isValidatable(observable) && !observable.isValid() && observable.isModified();\n\t\t\t\t});\n\t\t\t\treturn invalidAndModifiedPresent;\n\t\t\t};\n\n\t\t\tresult.filter = function(predicate) {\n\t\t\t\tpredicate = predicate || function () { return true; };\n\t\t\t\t// ensure we have latest changes\n\t\t\t\tresult();\n\n\t\t\t\treturn koUtils.arrayFilter(context.validatables, predicate);\n\t\t\t};\n\n\t\t\tresult.find = function(predicate) {\n\t\t\t\tpredicate = predicate || function () { return true; };\n\t\t\t\t// ensure we have latest changes\n\t\t\t\tresult();\n\n\t\t\t\treturn koUtils.arrayFirst(context.validatables, predicate);\n\t\t\t};\n\n\t\t\tresult.forEach = function(callback) {\n\t\t\t\tcallback = callback || function () { };\n\t\t\t\t// ensure we have latest changes\n\t\t\t\tresult();\n\n\t\t\t\tforEach(context.validatables, callback);\n\t\t\t};\n\n\t\t\tresult.map = function(mapping) {\n\t\t\t\tmapping = mapping || function (item) { return item; };\n\t\t\t\t// ensure we have latest changes\n\t\t\t\tresult();\n\n\t\t\t\treturn koUtils.arrayMap(context.validatables, mapping);\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * @private You should not rely on this method being here.\n\t\t\t * It's a private method and it may change in the future.\n\t\t\t *\n\t\t\t * @description Updates the validated object and collects errors from it.\n\t\t\t */\n\t\t\tresult._updateState = function(newValue) {\n\t\t\t\tif (!utils.isObject(newValue)) {\n\t\t\t\t\tthrow new Error('An object is required.');\n\t\t\t\t}\n\t\t\t\tobj = newValue;\n\t\t\t\tif (options.observable) {\n\t\t\t\t\tcontext.graphMonitor.valueHasMutated();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trunTraversal(newValue, context);\n\t\t\t\t\treturn collectErrors(context.validatables);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn result;\n\t\t},\n\n\t\tformatMessage: function (message, params, observable) {\n\t\t\tif (utils.isObject(params) && params.typeAttr) {\n\t\t\t\tparams = params.value;\n\t\t\t}\n\t\t\tif (typeof message === 'function') {\n\t\t\t\treturn message(params, observable);\n\t\t\t}\n\t\t\tvar replacements = unwrap(params);\n            if (replacements == null) {\n                replacements = [];\n            }\n\t\t\tif (!utils.isArray(replacements)) {\n\t\t\t\treplacements = [replacements];\n\t\t\t}\n\t\t\treturn message.replace(/{(\\d+)}/gi, function(match, index) {\n\t\t\t\tif (typeof replacements[index] !== 'undefined') {\n\t\t\t\t\treturn replacements[index];\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\t\t},\n\n\t\t// addRule:\n\t\t// This takes in a ko.observable and a Rule Context - which is just a rule name and params to supply to the validator\n\t\t// ie: kv.addRule(myObservable, {\n\t\t//\t\t  rule: 'required',\n\t\t//\t\t  params: true\n\t\t//\t  });\n\t\t//\n\t\taddRule: function (observable, rule) {\n\t\t\tobservable.extend({ validatable: true });\n\n\t\t\tvar hasRule = !!koUtils.arrayFirst(observable.rules(), function(item) {\n\t\t\t\treturn item.rule && item.rule === rule.rule;\n\t\t\t});\n\n\t\t\tif (!hasRule) {\n\t\t\t\t//push a Rule Context to the observables local array of Rule Contexts\n\t\t\t\tobservable.rules.push(rule);\n\t\t\t}\n\t\t\treturn observable;\n\t\t},\n\n\t\t// addAnonymousRule:\n\t\t// Anonymous Rules essentially have all the properties of a Rule, but are only specific for a certain property\n\t\t// and developers typically are wanting to add them on the fly or not register a rule with the 'kv.rules' object\n\t\t//\n\t\t// Example:\n\t\t// var test = ko.observable('something').extend{(\n\t\t//\t  validation: {\n\t\t//\t\t  validator: function(val, someOtherVal){\n\t\t//\t\t\t  return true;\n\t\t//\t\t  },\n\t\t//\t\t  message: \"Something must be really wrong!',\n\t\t//\t\t  params: true\n\t\t//\t  }\n\t\t//  )};\n\t\taddAnonymousRule: function (observable, ruleObj) {\n\t\t\tif (ruleObj['message'] === undefined) {\n\t\t\t\truleObj['message'] = 'Error';\n\t\t\t}\n\n\t\t\t//make sure onlyIf is honoured\n\t\t\tif (ruleObj.onlyIf) {\n\t\t\t\truleObj.condition = ruleObj.onlyIf;\n\t\t\t}\n\n\t\t\t//add the anonymous rule to the observable\n\t\t\tkv.addRule(observable, ruleObj);\n\t\t},\n\n\t\taddExtender: function (ruleName) {\n\t\t\tko.extenders[ruleName] = function (observable, params) {\n\t\t\t\t//params can come in a few flavors\n\t\t\t\t// 1. Just the params to be passed to the validator\n\t\t\t\t// 2. An object containing the Message to be used and the Params to pass to the validator\n\t\t\t\t// 3. A condition when the validation rule to be applied\n\t\t\t\t//\n\t\t\t\t// Example:\n\t\t\t\t// var test = ko.observable(3).extend({\n\t\t\t\t//\t  max: {\n\t\t\t\t//\t\t  message: 'This special field has a Max of {0}',\n\t\t\t\t//\t\t  params: 2,\n\t\t\t\t//\t\t  onlyIf: function() {\n\t\t\t\t//\t\t\t\t\t  return specialField.IsVisible();\n\t\t\t\t//\t\t\t\t  }\n\t\t\t\t//\t  }\n\t\t\t\t//  )};\n\t\t\t\t//\n\t\t\t\tif (params && (params.message || params.onlyIf)) { //if it has a message or condition object, then its an object literal to use\n\t\t\t\t\treturn kv.addRule(observable, {\n\t\t\t\t\t\trule: ruleName,\n\t\t\t\t\t\tmessage: params.message,\n\t\t\t\t\t\tparams: utils.isEmptyVal(params.params) ? true : params.params,\n\t\t\t\t\t\tcondition: params.onlyIf\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn kv.addRule(observable, {\n\t\t\t\t\t\trule: ruleName,\n\t\t\t\t\t\tparams: params\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\t\t// loops through all kv.rules and adds them as extenders to\n\t\t// ko.extenders\n\t\tregisterExtenders: function () { // root extenders optional, use 'validation' extender if would cause conflicts\n\t\t\tif (configuration.registerExtenders) {\n\t\t\t\tfor (var ruleName in kv.rules) {\n\t\t\t\t\tif (kv.rules.hasOwnProperty(ruleName)) {\n\t\t\t\t\t\tif (!ko.extenders[ruleName]) {\n\t\t\t\t\t\t\tkv.addExtender(ruleName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t//creates a span next to the @element with the specified error class\n\t\tinsertValidationMessage: function (element) {\n\t\t\tvar span = document.createElement('SPAN');\n\t\t\tspan.className = utils.getConfigOptions(element).errorMessageClass;\n\t\t\tutils.insertAfter(element, span);\n\t\t\treturn span;\n\t\t},\n\n\t\t// if html-5 validation attributes have been specified, this parses\n\t\t// the attributes on @element\n\t\tparseInputValidationAttributes: function (element, valueAccessor) {\n\t\t\tforEach(kv.configuration.html5Attributes, function (attr) {\n\t\t\t\tif (utils.hasAttribute(element, attr)) {\n\n\t\t\t\t\tvar params = element.getAttribute(attr) || true;\n\n\t\t\t\t\tif (attr === 'min' || attr === 'max')\n\t\t\t\t\t{\n\t\t\t\t\t\t// If we're validating based on the min and max attributes, we'll\n\t\t\t\t\t\t// need to know what the 'type' attribute is set to\n\t\t\t\t\t\tvar typeAttr = element.getAttribute('type');\n\t\t\t\t\t\tif (typeof typeAttr === \"undefined\" || !typeAttr)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// From http://www.w3.org/TR/html-markup/input:\n\t\t\t\t\t\t\t//   An input element with no type attribute specified represents the\n\t\t\t\t\t\t\t//   same thing as an input element with its type attribute set to \"text\".\n\t\t\t\t\t\t\ttypeAttr = \"text\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparams = {typeAttr: typeAttr, value: params};\n\t\t\t\t\t}\n\n\t\t\t\t\tkv.addRule(valueAccessor(), {\n\t\t\t\t\t\trule: attr,\n\t\t\t\t\t\tparams: params\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tvar currentType = element.getAttribute('type');\n\t\t\tforEach(kv.configuration.html5InputTypes, function (type) {\n\t\t\t\tif (type === currentType) {\n\t\t\t\t\tkv.addRule(valueAccessor(), {\n\t\t\t\t\t\trule: (type === 'date') ? 'dateISO' : type,\n\t\t\t\t\t\tparams: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t// writes html5 validation attributes on the element passed in\n\t\twriteInputValidationAttributes: function (element, valueAccessor) {\n\t\t\tvar observable = valueAccessor();\n\n\t\t\tif (!observable || !observable.rules) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar contexts = observable.rules(); // observable array\n\n\t\t\t// loop through the attributes and add the information needed\n\t\t\tforEach(kv.configuration.html5Attributes, function (attr) {\n\t\t\t\tvar ctx = koUtils.arrayFirst(contexts, function (ctx) {\n\t\t\t\t\treturn ctx.rule && ctx.rule.toLowerCase() === attr.toLowerCase();\n\t\t\t\t});\n\n\t\t\t\tif (!ctx) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// we have a rule matching a validation attribute at this point\n\t\t\t\t// so lets add it to the element along with the params\n\t\t\t\tko.computed({\n\t\t\t\t\tread: function() {\n\t\t\t\t\t\tvar params = ko.unwrap(ctx.params);\n\n\t\t\t\t\t\t// we have to do some special things for the pattern validation\n\t\t\t\t\t\tif (ctx.rule === \"pattern\" && params instanceof RegExp) {\n\t\t\t\t\t\t\t// we need the pure string representation of the RegExpr without the //gi stuff\n\t\t\t\t\t\t\tparams = params.source;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telement.setAttribute(attr, params);\n\t\t\t\t\t},\n\t\t\t\t\tdisposeWhenNodeIsRemoved: element\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tcontexts = null;\n\t\t},\n\n\t\t//take an existing binding handler and make it cause automatic validations\n\t\tmakeBindingHandlerValidatable: function (handlerName) {\n\t\t\tvar init = ko.bindingHandlers[handlerName].init;\n\n\t\t\tko.bindingHandlers[handlerName].init = function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n\n\t\t\t\tinit(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);\n\n\t\t\t\treturn ko.bindingHandlers['validationCore'].init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);\n\t\t\t};\n\t\t},\n\n\t\t// visit an objects properties and apply validation rules from a definition\n\t\tsetRules: function (target, definition) {\n\t\t\tvar setRules = function (target, definition) {\n\t\t\t\tif (!target || !definition) { return; }\n\n\t\t\t\tfor (var prop in definition) {\n\t\t\t\t\tif (!definition.hasOwnProperty(prop)) { continue; }\n\t\t\t\t\tvar ruleDefinitions = definition[prop];\n\n\t\t\t\t\t//check the target property exists and has a value\n\t\t\t\t\tif (!target[prop]) { continue; }\n\t\t\t\t\tvar targetValue = target[prop],\n\t\t\t\t\t\tunwrappedTargetValue = unwrap(targetValue),\n\t\t\t\t\t\trules = {},\n\t\t\t\t\t\tnonRules = {};\n\n\t\t\t\t\tfor (var rule in ruleDefinitions) {\n\t\t\t\t\t\tif (!ruleDefinitions.hasOwnProperty(rule)) { continue; }\n\t\t\t\t\t\tif (kv.rules[rule]) {\n\t\t\t\t\t\t\trules[rule] = ruleDefinitions[rule];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnonRules[rule] = ruleDefinitions[rule];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//apply rules\n\t\t\t\t\tif (ko.isObservable(targetValue)) {\n\t\t\t\t\t\ttargetValue.extend(rules);\n\t\t\t\t\t}\n\n\t\t\t\t\t//then apply child rules\n\t\t\t\t\t//if it's an array, apply rules to all children\n\t\t\t\t\tif (unwrappedTargetValue && utils.isArray(unwrappedTargetValue)) {\n\t\t\t\t\t\tfor (var i = 0; i < unwrappedTargetValue.length; i++) {\n\t\t\t\t\t\t\tsetRules(unwrappedTargetValue[i], nonRules);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//otherwise, just apply to this property\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsetRules(unwrappedTargetValue, nonRules);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tsetRules(target, definition);\n\t\t}\n\t};\n\n}());\n\n// expose api publicly\nextend(ko.validation, api);\n;//Validation Rules:\n// You can view and override messages or rules via:\n// kv.rules[ruleName]\n//\n// To implement a custom Rule, simply use this template:\n// kv.rules['<custom rule name>'] = {\n//      validator: function (val, param) {\n//          <custom logic>\n//          return <true or false>;\n//      },\n//      message: '<custom validation message>' //optionally you can also use a '{0}' to denote a placeholder that will be replaced with your 'param'\n// };\n//\n// Example:\n// kv.rules['mustEqual'] = {\n//      validator: function( val, mustEqualVal ){\n//          return val === mustEqualVal;\n//      },\n//      message: 'This field must equal {0}'\n// };\n//\nkv.rules = {};\nkv.rules['required'] = {\n\tvalidator: function (val, required) {\n\t\tvar testVal;\n\n\t\tif (val === undefined || val === null) {\n\t\t\treturn !required;\n\t\t}\n\n\t\ttestVal = val;\n\t\tif (typeof (val) === 'string') {\n\t\t\tif (String.prototype.trim) {\n\t\t\t\ttestVal = val.trim();\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttestVal = val.replace(/^\\s+|\\s+$/g, '');\n\t\t\t}\n\t\t}\n\n\t\tif (!required) {// if they passed: { required: false }, then don't require this\n\t\t\treturn true;\n\t\t}\n\n\t\treturn ((testVal + '').length > 0);\n\t},\n\tmessage: 'This field is required.'\n};\n\nfunction minMaxValidatorFactory(validatorName) {\n    var isMaxValidation = validatorName === \"max\";\n\n    return function (val, options) {\n        if (kv.utils.isEmptyVal(val)) {\n            return true;\n        }\n\n        var comparisonValue, type;\n        if (options.typeAttr === undefined) {\n            // This validator is being called from javascript rather than\n            // being bound from markup\n            type = \"text\";\n            comparisonValue = options;\n        } else {\n            type = options.typeAttr;\n            comparisonValue = options.value;\n        }\n\n        // From http://www.w3.org/TR/2012/WD-html5-20121025/common-input-element-attributes.html#attr-input-min,\n        // if the value is parseable to a number, then the minimum should be numeric\n        if (!isNaN(comparisonValue) && !(comparisonValue instanceof Date)) {\n            type = \"number\";\n        }\n\n        var regex, valMatches, comparisonValueMatches;\n        switch (type.toLowerCase()) {\n            case \"week\":\n                regex = /^(\\d{4})-W(\\d{2})$/;\n                valMatches = val.match(regex);\n                if (valMatches === null) {\n                    throw new Error(\"Invalid value for \" + validatorName + \" attribute for week input.  Should look like \" +\n                        \"'2000-W33' http://www.w3.org/TR/html-markup/input.week.html#input.week.attrs.min\");\n                }\n                comparisonValueMatches = comparisonValue.match(regex);\n                // If no regex matches were found, validation fails\n                if (!comparisonValueMatches) {\n                    return false;\n                }\n\n                if (isMaxValidation) {\n                    return (valMatches[1] < comparisonValueMatches[1]) || // older year\n                        // same year, older week\n                        ((valMatches[1] === comparisonValueMatches[1]) && (valMatches[2] <= comparisonValueMatches[2]));\n                } else {\n                    return (valMatches[1] > comparisonValueMatches[1]) || // newer year\n                        // same year, newer week\n                        ((valMatches[1] === comparisonValueMatches[1]) && (valMatches[2] >= comparisonValueMatches[2]));\n                }\n                break;\n\n            case \"month\":\n                regex = /^(\\d{4})-(\\d{2})$/;\n                valMatches = val.match(regex);\n                if (valMatches === null) {\n                    throw new Error(\"Invalid value for \" + validatorName + \" attribute for month input.  Should look like \" +\n                        \"'2000-03' http://www.w3.org/TR/html-markup/input.month.html#input.month.attrs.min\");\n                }\n                comparisonValueMatches = comparisonValue.match(regex);\n                // If no regex matches were found, validation fails\n                if (!comparisonValueMatches) {\n                    return false;\n                }\n\n                if (isMaxValidation) {\n                    return ((valMatches[1] < comparisonValueMatches[1]) || // older year\n                        // same year, older month\n                        ((valMatches[1] === comparisonValueMatches[1]) && (valMatches[2] <= comparisonValueMatches[2])));\n                } else {\n                    return (valMatches[1] > comparisonValueMatches[1]) || // newer year\n                        // same year, newer month\n                        ((valMatches[1] === comparisonValueMatches[1]) && (valMatches[2] >= comparisonValueMatches[2]));\n                }\n                break;\n\n            case \"number\":\n            case \"range\":\n                if (isMaxValidation) {\n                    return (!isNaN(val) && parseFloat(val) <= parseFloat(comparisonValue));\n                } else {\n                    return (!isNaN(val) && parseFloat(val) >= parseFloat(comparisonValue));\n                }\n                break;\n\n            default:\n                if (isMaxValidation) {\n                    return val <= comparisonValue;\n                } else {\n                    return val >= comparisonValue;\n                }\n        }\n    };\n}\n\nkv.rules['min'] = {\n\tvalidator: minMaxValidatorFactory(\"min\"),\n\tmessage: 'Please enter a value greater than or equal to {0}.'\n};\n\nkv.rules['max'] = {\n\tvalidator: minMaxValidatorFactory(\"max\"),\n\tmessage: 'Please enter a value less than or equal to {0}.'\n};\n\nkv.rules['minLength'] = {\n\tvalidator: function (val, minLength) {\n\t\tif(kv.utils.isEmptyVal(val)) { return true; }\n\t\tvar normalizedVal = kv.utils.isNumber(val) ? ('' + val) : val;\n\t\treturn normalizedVal.length >= minLength;\n\t},\n\tmessage: 'Please enter at least {0} characters.'\n};\n\nkv.rules['maxLength'] = {\n\tvalidator: function (val, maxLength) {\n\t\tif(kv.utils.isEmptyVal(val)) { return true; }\n\t\tvar normalizedVal = kv.utils.isNumber(val) ? ('' + val) : val;\n\t\treturn normalizedVal.length <= maxLength;\n\t},\n\tmessage: 'Please enter no more than {0} characters.'\n};\n\nkv.rules['pattern'] = {\n\tvalidator: function (val, regex) {\n\t\treturn kv.utils.isEmptyVal(val) || val.toString().match(regex) !== null;\n\t},\n\tmessage: 'Please check this value.'\n};\n\nkv.rules['step'] = {\n\tvalidator: function (val, step) {\n\n\t\t// in order to handle steps of .1 & .01 etc.. Modulus won't work\n\t\t// if the value is a decimal, so we have to correct for that\n\t\tif (kv.utils.isEmptyVal(val) || step === 'any') { return true; }\n\t\tvar dif = (val * 100) % (step * 100);\n\t\treturn Math.abs(dif) < 0.00001 || Math.abs(1 - dif) < 0.00001;\n\t},\n\tmessage: 'The value must increment by {0}.'\n};\n\nkv.rules['email'] = {\n\tvalidator: function (val, validate) {\n\t\tif (!validate) { return true; }\n\n\t\t//I think an empty email address is also a valid entry\n\t\t//if one want's to enforce entry it should be done with 'required: true'\n\t\treturn kv.utils.isEmptyVal(val) || (\n\t\t\t// jquery validate regex - thanks Scott Gonzalez\n\t\t\tvalidate && /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i.test(val)\n\t\t);\n\t},\n\tmessage: 'Please enter a proper email address.'\n};\n\nkv.rules['date'] = {\n\tvalidator: function (value, validate) {\n\t\tif (!validate) { return true; }\n\t\treturn kv.utils.isEmptyVal(value) || (validate && !/Invalid|NaN/.test(new Date(value)));\n\t},\n\tmessage: 'Please enter a proper date.'\n};\n\nkv.rules['dateISO'] = {\n\tvalidator: function (value, validate) {\n\t\tif (!validate) { return true; }\n\t\treturn kv.utils.isEmptyVal(value) || (validate && /^\\d{4}[-/](?:0?[1-9]|1[012])[-/](?:0?[1-9]|[12][0-9]|3[01])$/.test(value));\n\t},\n\tmessage: 'Please enter a proper date.'\n};\n\nkv.rules['number'] = {\n\tvalidator: function (value, validate) {\n\t\tif (!validate) { return true; }\n\t\treturn kv.utils.isEmptyVal(value) || (validate && /^-?(?:\\d+|\\d{1,3}(?:,\\d{3})+)?(?:\\.\\d+)?$/.test(value));\n\t},\n\tmessage: 'Please enter a number.'\n};\n\nkv.rules['digit'] = {\n\tvalidator: function (value, validate) {\n\t\tif (!validate) { return true; }\n\t\treturn kv.utils.isEmptyVal(value) || (validate && /^\\d+$/.test(value));\n\t},\n\tmessage: 'Please enter a digit.'\n};\n\nkv.rules['phoneUS'] = {\n\tvalidator: function (phoneNumber, validate) {\n\t\tif (!validate) { return true; }\n\t\tif (kv.utils.isEmptyVal(phoneNumber)) { return true; } // makes it optional, use 'required' rule if it should be required\n\t\tif (typeof (phoneNumber) !== 'string') { return false; }\n\t\tphoneNumber = phoneNumber.replace(/\\s+/g, \"\");\n\t\treturn validate && phoneNumber.length > 9 && phoneNumber.match(/^(1-?)?(\\([2-9]\\d{2}\\)|[2-9]\\d{2})-?[2-9]\\d{2}-?\\d{4}$/);\n\t},\n\tmessage: 'Please specify a valid phone number.'\n};\n\nkv.rules['equal'] = {\n\tvalidator: function (val, params) {\n\t\tvar otherValue = params;\n\t\treturn val === kv.utils.getValue(otherValue);\n\t},\n\tmessage: 'Values must equal.'\n};\n\nkv.rules['notEqual'] = {\n\tvalidator: function (val, params) {\n\t\tvar otherValue = params;\n\t\treturn val !== kv.utils.getValue(otherValue);\n\t},\n\tmessage: 'Please choose another value.'\n};\n\n//unique in collection\n// options are:\n//    collection: array or function returning (observable) array\n//              in which the value has to be unique\n//    valueAccessor: function that returns value from an object stored in collection\n//              if it is null the value is compared directly\n//    external: set to true when object you are validating is automatically updating collection\nkv.rules['unique'] = {\n\tvalidator: function (val, options) {\n\t\tvar c = kv.utils.getValue(options.collection),\n\t\t\texternal = kv.utils.getValue(options.externalValue),\n\t\t\tcounter = 0;\n\n\t\tif (!val || !c) { return true; }\n\n\t\tkoUtils.arrayFilter(c, function (item) {\n\t\t\tif (val === (options.valueAccessor ? options.valueAccessor(item) : item)) { counter++; }\n\t\t});\n\t\t// if value is external even 1 same value in collection means the value is not unique\n\t\treturn counter < (!!external ? 1 : 2);\n\t},\n\tmessage: 'Please make sure the value is unique.'\n};\n\n\n//now register all of these!\n(function () {\n\tkv.registerExtenders();\n}());\n;// The core binding handler\n// this allows us to setup any value binding that internally always\n// performs the same functionality\nko.bindingHandlers['validationCore'] = (function () {\n\n\treturn {\n\t\tinit: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n\t\t\tvar config = kv.utils.getConfigOptions(element);\n\t\t\tvar observable = valueAccessor();\n\n\t\t\t// parse html5 input validation attributes, optional feature\n\t\t\tif (config.parseInputAttributes) {\n\t\t\t\tkv.utils.async(function () { kv.parseInputValidationAttributes(element, valueAccessor); });\n\t\t\t}\n\n\t\t\t// if requested insert message element and apply bindings\n\t\t\tif (config.insertMessages && kv.utils.isValidatable(observable)) {\n\n\t\t\t\t// insert the <span></span>\n\t\t\t\tvar validationMessageElement = kv.insertValidationMessage(element);\n\n\t\t\t\t// if we're told to use a template, make sure that gets rendered\n\t\t\t\tif (config.messageTemplate) {\n\t\t\t\t\tko.renderTemplate(config.messageTemplate, { field: observable }, null, validationMessageElement, 'replaceNode');\n\t\t\t\t} else {\n\t\t\t\t\tko.applyBindingsToNode(validationMessageElement, { validationMessage: observable });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// write the html5 attributes if indicated by the config\n\t\t\tif (config.writeInputAttributes && kv.utils.isValidatable(observable)) {\n\n\t\t\t\tkv.writeInputValidationAttributes(element, valueAccessor);\n\t\t\t}\n\n\t\t\t// if requested, add binding to decorate element\n\t\t\tif (config.decorateInputElement && kv.utils.isValidatable(observable)) {\n\t\t\t\tko.applyBindingsToNode(element, { validationElement: observable });\n\t\t\t}\n\t\t}\n\t};\n\n}());\n\n// override for KO's default 'value', 'checked', 'textInput' and selectedOptions bindings\nkv.makeBindingHandlerValidatable(\"value\");\nkv.makeBindingHandlerValidatable(\"checked\");\nif (ko.bindingHandlers.textInput) {\n\tkv.makeBindingHandlerValidatable(\"textInput\");\n}\nkv.makeBindingHandlerValidatable(\"selectedOptions\");\n\n\nko.bindingHandlers['validationMessage'] = { // individual error message, if modified or post binding\n\tupdate: function (element, valueAccessor) {\n\t\tvar obsv = valueAccessor(),\n\t\t\tconfig = kv.utils.getConfigOptions(element),\n\t\t\tval = unwrap(obsv),\n\t\t\tmsg = null,\n\t\t\tisModified = false,\n\t\t\tisValid = false;\n\n\t\tif (obsv === null || typeof obsv === 'undefined') {\n\t\t\tthrow new Error('Cannot bind validationMessage to undefined value. data-bind expression: ' +\n\t\t\t\telement.getAttribute('data-bind'));\n\t\t}\n\n\t\tisModified = obsv.isModified && obsv.isModified();\n\t\tisValid = obsv.isValid && obsv.isValid();\n\n\t\tvar error = null;\n\t\tif (!config.messagesOnModified || isModified) {\n\t\t\terror = isValid ? null : obsv.error;\n\t\t}\n\n\t\tvar isVisible = !config.messagesOnModified || isModified ? !isValid : false;\n\t\tvar isCurrentlyVisible = element.style.display !== \"none\";\n\n\t\tif (config.allowHtmlMessages) {\n\t\t\tkoUtils.setHtml(element, error);\n\t\t} else {\n\t\t\tko.bindingHandlers.text.update(element, function () { return error; });\n\t\t}\n\n\t\tif (isCurrentlyVisible && !isVisible) {\n\t\t\telement.style.display = 'none';\n\t\t} else if (!isCurrentlyVisible && isVisible) {\n\t\t\telement.style.display = '';\n\t\t}\n\t}\n};\n\nko.bindingHandlers['validationElement'] = {\n\tupdate: function (element, valueAccessor, allBindingsAccessor) {\n\t\tvar obsv = valueAccessor(),\n\t\t\tconfig = kv.utils.getConfigOptions(element),\n\t\t\tval = unwrap(obsv),\n\t\t\tmsg = null,\n\t\t\tisModified = false,\n\t\t\tisValid = false;\n\n\t\tif (obsv === null || typeof obsv === 'undefined') {\n\t\t\tthrow new Error('Cannot bind validationElement to undefined value. data-bind expression: ' +\n\t\t\t\telement.getAttribute('data-bind'));\n\t\t}\n\n\t\tisModified = obsv.isModified && obsv.isModified();\n\t\tisValid = obsv.isValid && obsv.isValid();\n\n\t\t// create an evaluator function that will return something like:\n\t\t// css: { validationElement: true }\n\t\tvar cssSettingsAccessor = function () {\n\t\t\tvar css = {};\n\n\t\t\tvar shouldShow = ((!config.decorateElementOnModified || isModified) ? !isValid : false);\n\n\t\t\t// css: { validationElement: false }\n\t\t\tcss[config.errorElementClass] = shouldShow;\n\n\t\t\treturn css;\n\t\t};\n\n\t\t//add or remove class on the element;\n\t\tko.bindingHandlers.css.update(element, cssSettingsAccessor, allBindingsAccessor);\n\t\tif (!config.errorsAsTitle) { return; }\n\n\t\tko.bindingHandlers.attr.update(element, function () {\n\t\t\tvar\n\t\t\t\thasModification = !config.errorsAsTitleOnModified || isModified,\n\t\t\t\ttitle = kv.utils.getOriginalElementTitle(element);\n\n\t\t\tif (hasModification && !isValid) {\n\t\t\t\treturn { title: obsv.error, 'data-orig-title': title };\n\t\t\t} else if (!hasModification || isValid) {\n\t\t\t\treturn { title: title, 'data-orig-title': null };\n\t\t\t}\n\t\t});\n\t}\n};\n\n// ValidationOptions:\n// This binding handler allows you to override the initial config by setting any of the options for a specific element or context of elements\n//\n// Example:\n// <div data-bind=\"validationOptions: { insertMessages: true, messageTemplate: 'customTemplate', errorMessageClass: 'mySpecialClass'}\">\n//      <input type=\"text\" data-bind=\"value: someValue\"/>\n//      <input type=\"text\" data-bind=\"value: someValue2\"/>\n// </div>\nko.bindingHandlers['validationOptions'] = (function () {\n\treturn {\n\t\tinit: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n\t\t\tvar options = unwrap(valueAccessor());\n\t\t\tif (options) {\n\t\t\t\tvar newConfig = extend({}, kv.configuration);\n\t\t\t\textend(newConfig, options);\n\n\t\t\t\t//store the validation options on the node so we can retrieve it later\n\t\t\t\tkv.utils.setDomData(element, newConfig);\n\t\t\t}\n\t\t}\n\t};\n}());\n;// Validation Extender:\n// This is for creating custom validation logic on the fly\n// Example:\n// var test = ko.observable('something').extend{(\n//      validation: {\n//          validator: function(val, someOtherVal){\n//              return true;\n//          },\n//          message: \"Something must be really wrong!',\n//          params: true\n//      }\n//  )};\nko.extenders['validation'] = function (observable, rules) { // allow single rule or array\n\tforEach(kv.utils.isArray(rules) ? rules : [rules], function (rule) {\n\t\t// the 'rule' being passed in here has no name to identify a core Rule,\n\t\t// so we add it as an anonymous rule\n\t\t// If the developer is wanting to use a core Rule, but use a different message see the 'addExtender' logic for examples\n\t\tkv.addAnonymousRule(observable, rule);\n\t});\n\treturn observable;\n};\n\n//This is the extender that makes a Knockout Observable also 'Validatable'\n//examples include:\n// 1. var test = ko.observable('something').extend({validatable: true});\n// this will ensure that the Observable object is setup properly to respond to rules\n//\n// 2. test.extend({validatable: false});\n// this will remove the validation properties from the Observable object should you need to do that.\nko.extenders['validatable'] = function (observable, options) {\n\tif (!kv.utils.isObject(options)) {\n\t\toptions = { enable: options };\n\t}\n\n\tif (!('enable' in options)) {\n\t\toptions.enable = true;\n\t}\n\n\tif (options.enable && !kv.utils.isValidatable(observable)) {\n\t\tvar config = kv.configuration.validate || {};\n\t\tvar validationOptions = {\n\t\t\tthrottleEvaluation : options.throttle || config.throttle\n\t\t};\n\n\t\tobservable.error = ko.observable(null); // holds the error message, we only need one since we stop processing validators when one is invalid\n\n\t\t// observable.rules:\n\t\t// ObservableArray of Rule Contexts, where a Rule Context is simply the name of a rule and the params to supply to it\n\t\t//\n\t\t// Rule Context = { rule: '<rule name>', params: '<passed in params>', message: '<Override of default Message>' }\n\t\tobservable.rules = ko.observableArray(); //holds the rule Contexts to use as part of validation\n\n\t\t//in case async validation is occurring\n\t\tobservable.isValidating = ko.observable(false);\n\n\t\t//the true holder of whether the observable is valid or not\n\t\tobservable.__valid__ = ko.observable(true);\n\n\t\tobservable.isModified = ko.observable(false);\n\n\t\t// a semi-protected observable\n\t\tobservable.isValid = ko.computed(observable.__valid__);\n\n\t\t//manually set error state\n\t\tobservable.setError = function (error) {\n\t\t\tvar previousError = observable.error.peek();\n\t\t\tvar previousIsValid = observable.__valid__.peek();\n\n\t\t\tobservable.error(error);\n\t\t\tobservable.__valid__(false);\n\n\t\t\tif (previousError !== error && !previousIsValid) {\n\t\t\t\t// if the observable was not valid before then isValid will not mutate,\n\t\t\t\t// hence causing any grouping to not display the latest error.\n\t\t\t\tobservable.isValid.notifySubscribers();\n\t\t\t}\n\t\t};\n\n\t\t//manually clear error state\n\t\tobservable.clearError = function () {\n\t\t\tobservable.error(null);\n\t\t\tobservable.__valid__(true);\n\t\t\treturn observable;\n\t\t};\n\n\t\t//subscribe to changes in the observable\n\t\tvar h_change = observable.subscribe(function () {\n\t\t\tobservable.isModified(true);\n\t\t});\n\n\t\t// we use a computed here to ensure that anytime a dependency changes, the\n\t\t// validation logic evaluates\n\t\tvar h_obsValidationTrigger = ko.computed(extend({\n\t\t\tread: function () {\n\t\t\t\tvar obs = observable(),\n\t\t\t\t\truleContexts = observable.rules();\n\n\t\t\t\tkv.validateObservable(observable);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}, validationOptions));\n\n\t\textend(h_obsValidationTrigger, validationOptions);\n\n\t\tobservable._disposeValidation = function () {\n\t\t\t//first dispose of the subscriptions\n\t\t\tobservable.isValid.dispose();\n\t\t\tobservable.rules.removeAll();\n\t\t\th_change.dispose();\n\t\t\th_obsValidationTrigger.dispose();\n\n\t\t\tdelete observable['rules'];\n\t\t\tdelete observable['error'];\n\t\t\tdelete observable['isValid'];\n\t\t\tdelete observable['isValidating'];\n\t\t\tdelete observable['__valid__'];\n\t\t\tdelete observable['isModified'];\n            delete observable['setError'];\n            delete observable['clearError'];\n            delete observable['_disposeValidation'];\n\t\t};\n\t} else if (options.enable === false && observable._disposeValidation) {\n\t\tobservable._disposeValidation();\n\t}\n\treturn observable;\n};\n\nfunction validateSync(observable, rule, ctx) {\n\t//Execute the validator and see if its valid\n\tif (!rule.validator(observable(), (ctx.params === undefined ? true : unwrap(ctx.params)))) { // default param is true, eg. required = true\n\n\t\t//not valid, so format the error message and stick it in the 'error' variable\n\t\tobservable.setError(kv.formatMessage(\n\t\t\t\t\tctx.message || rule.message,\n\t\t\t\t\tunwrap(ctx.params),\n\t\t\t\t\tobservable));\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}\n\nfunction validateAsync(observable, rule, ctx) {\n\tobservable.isValidating(true);\n\n\tvar callBack = function (valObj) {\n\t\tvar isValid = false,\n\t\t\tmsg = '';\n\n\t\tif (!observable.__valid__()) {\n\n\t\t\t// since we're returning early, make sure we turn this off\n\t\t\tobservable.isValidating(false);\n\n\t\t\treturn; //if its already NOT valid, don't add to that\n\t\t}\n\n\t\t//we were handed back a complex object\n\t\tif (valObj['message']) {\n\t\t\tisValid = valObj.isValid;\n\t\t\tmsg = valObj.message;\n\t\t} else {\n\t\t\tisValid = valObj;\n\t\t}\n\n\t\tif (!isValid) {\n\t\t\t//not valid, so format the error message and stick it in the 'error' variable\n\t\t\tobservable.error(kv.formatMessage(\n\t\t\t\tmsg || ctx.message || rule.message,\n\t\t\t\tunwrap(ctx.params),\n\t\t\t\tobservable));\n\t\t\tobservable.__valid__(isValid);\n\t\t}\n\n\t\t// tell it that we're done\n\t\tobservable.isValidating(false);\n\t};\n\n\tkv.utils.async(function() {\n\t    //fire the validator and hand it the callback\n        rule.validator(observable(), ctx.params === undefined ? true : unwrap(ctx.params), callBack);\n\t});\n}\n\nkv.validateObservable = function (observable) {\n\tvar i = 0,\n\t\trule, // the rule validator to execute\n\t\tctx, // the current Rule Context for the loop\n\t\truleContexts = observable.rules(), //cache for iterator\n\t\tlen = ruleContexts.length; //cache for iterator\n\n\tfor (; i < len; i++) {\n\n\t\t//get the Rule Context info to give to the core Rule\n\t\tctx = ruleContexts[i];\n\n\t\t// checks an 'onlyIf' condition\n\t\tif (ctx.condition && !ctx.condition()) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t//get the core Rule to use for validation\n\t\trule = ctx.rule ? kv.rules[ctx.rule] : ctx;\n\n\t\tif (rule['async'] || ctx['async']) {\n\t\t\t//run async validation\n\t\t\tvalidateAsync(observable, rule, ctx);\n\n\t\t} else {\n\t\t\t//run normal sync validation\n\t\t\tif (!validateSync(observable, rule, ctx)) {\n\t\t\t\treturn false; //break out of the loop\n\t\t\t}\n\t\t}\n\t}\n\t//finally if we got this far, make the observable valid again!\n\tobservable.clearError();\n\treturn true;\n};\n;\nvar _locales = {};\nvar _currentLocale;\n\nkv.defineLocale = function(name, values) {\n\tif (name && values) {\n\t\t_locales[name.toLowerCase()] = values;\n\t\treturn values;\n\t}\n\treturn null;\n};\n\nkv.locale = function(name) {\n\tif (name) {\n\t\tname = name.toLowerCase();\n\n\t\tif (_locales.hasOwnProperty(name)) {\n\t\t\tkv.localize(_locales[name]);\n\t\t\t_currentLocale = name;\n\t\t}\n\t\telse {\n\t\t\tthrow new Error('Localization ' + name + ' has not been loaded.');\n\t\t}\n\t}\n\treturn _currentLocale;\n};\n\n//quick function to override rule messages\nkv.localize = function (msgTranslations) {\n\tvar rules = kv.rules;\n\n\t//loop the properties in the object and assign the msg to the rule\n\tfor (var ruleName in msgTranslations) {\n\t\tif (rules.hasOwnProperty(ruleName)) {\n\t\t\trules[ruleName].message = msgTranslations[ruleName];\n\t\t}\n\t}\n};\n\n// Populate default locale (this will make en-US.js somewhat redundant)\n(function() {\n\tvar localeData = {};\n\tvar rules = kv.rules;\n\n\tfor (var ruleName in rules) {\n\t\tif (rules.hasOwnProperty(ruleName)) {\n\t\t\tlocaleData[ruleName] = rules[ruleName].message;\n\t\t}\n\t}\n\tkv.defineLocale('en-us', localeData);\n})();\n\n// No need to invoke locale because the messages are already defined along with the rules for en-US\n_currentLocale = 'en-us';\n;/**\n * Possible invocations:\n * \t\tapplyBindingsWithValidation(viewModel)\n * \t\tapplyBindingsWithValidation(viewModel, options)\n * \t\tapplyBindingsWithValidation(viewModel, rootNode)\n *\t\tapplyBindingsWithValidation(viewModel, rootNode, options)\n */\nko.applyBindingsWithValidation = function (viewModel, rootNode, options) {\n\tvar node = document.body,\n\t\tconfig;\n\n\tif (rootNode && rootNode.nodeType) {\n\t\tnode = rootNode;\n\t\tconfig = options;\n\t}\n\telse {\n\t\tconfig = rootNode;\n\t}\n\n\tkv.init();\n\n\tif (config) {\n\t\tconfig = extend(extend({}, kv.configuration), config);\n\t\tkv.utils.setDomData(node, config);\n\t}\n\n\tko.applyBindings(viewModel, node);\n};\n\n//override the original applyBindings so that we can ensure all new rules and what not are correctly registered\nvar origApplyBindings = ko.applyBindings;\nko.applyBindings = function (viewModel, rootNode) {\n\n\tkv.init();\n\n\torigApplyBindings(viewModel, rootNode);\n};\n\nko.validatedObservable = function (initialValue, options) {\n\tif (!options && !kv.utils.isObject(initialValue)) {\n\t\treturn ko.observable(initialValue).extend({ validatable: true });\n\t}\n\n\tvar obsv = ko.observable(initialValue);\n\tobsv.errors = kv.group(kv.utils.isObject(initialValue) ? initialValue : {}, options);\n\tobsv.isValid = ko.observable(obsv.errors().length === 0);\n\n\tif (ko.isObservable(obsv.errors)) {\n\t\tobsv.errors.subscribe(function(errors) {\n\t\t\tobsv.isValid(errors.length === 0);\n\t\t});\n\t}\n\telse {\n\t\tko.computed(obsv.errors).subscribe(function (errors) {\n\t\t\tobsv.isValid(errors.length === 0);\n\t\t});\n\t}\n\n\tobsv.subscribe(function(newValue) {\n\t\tif (!kv.utils.isObject(newValue)) {\n\t\t\t/*\n\t\t\t * The validation group works on objects.\n\t\t\t * Since the new value is a primitive (scalar, null or undefined) we need\n\t\t\t * to create an empty object to pass along.\n\t\t\t */\n\t\t\tnewValue = {};\n\t\t}\n\t\t// Force the group to refresh\n\t\tobsv.errors._updateState(newValue);\n\t\tobsv.isValid(obsv.errors().length === 0);\n\t});\n\n\treturn obsv;\n};\n;}));"]}